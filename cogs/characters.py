import discordimport randomimport jsonfrom discord.ext import commands, tasksfrom itertools import cycleimport sqlite3import asyncioimport math#########################################################################################################################   Character Class                                                                                                    ##                                                                                                                      ##   This class is to contain all commands for making characters and its associated data.                               ##   This class will need to create/read/update/delete (CRUD) for conditions, abilities, spells, levels, races,         ##   classes and characters.                                                                                            #########################################################################################################################async def can_be_int(val):    try:        int(val)        return True    except ValueError:        return Falseasync def can_list_be_int(string_list):    correct = True    for i in string_list:        if can_be_int(i):            correct = True        else:            return False    return correctasync def get_val_from_json(ctx, file):    with open(file, 'r') as f:        val = json.load(f)    return val[str(ctx.guild.id)]class Characters(commands.Cog):    ####################################################################################################################    #   Necessary Code                                                                                                 #    ####################################################################################################################    def __init__(self, client):        self.client = client    ####################################################################################################################    #   Conditions                                                                                                     #    ####################################################################################################################    #database command for create    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_cond_by_db(self, ctx, name, type, turns, damage, cond_roll, gain_loss, effect_stat, value_effect, lose_turn, *, desc):        successful = True        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, val_removed, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        error_loc = ''        if not type == "PHYSICAL" or not type == "SPECIAL":            successful = False            error_loc = 'move type'        if damage.find('d') == -1:            successful = False            error_loc = 'damage dice'        elif damage.find('d') != -1:            x = damage.split('d')            if not can_be_int(x[0]) or not can_be_int(x[1]):                successful = False                error_loc = 'damage dice'            elif int(x[0]) < 0 or int(x[1]) < 0 :                successful = False                error_loc = 'damage dice'        elif  damage != 'NONE':            successful = False            error_loc = 'damage dice'        if cond_roll != 'NONE' or cond_roll != 'stat1' or cond_roll != 'stat2' or cond_roll != 'stat3' or cond_roll != 'stat4' or cond_roll != 'stat5' or cond_roll != 'stat6':            successful = False            error_loc = 'stat to roll to break free'        if gain_loss != 'GAIN' or not gain_loss == 'LOSS':            successful = False            error_loc = 'gain or loss'        if effect_stat != 'HP' or effect_stat != 'MP' or effect_stat != 'EP' or effect_stat != 'stat1' or effect_stat != 'stat2' or effect_stat != 'stat3' or effect_stat != 'stat4' or effect_stat != 'stat5' or effect_stat != 'stat6':            successful = False            error_loc = 'stat effected'        if not can_be_int(value_effect):            successful = False            error_loc = 'value changed'        if lose_turn.find('d') == -1:            successful = False            error_loc = 'lose a turn'        elif lose_turn.find('d') != -1:            x = lose_turn.split('d')            if not can_be_int(x[0]) or can_be_int(x[1]):                successful = False                error_loc = 'lose a turn'            elif int(x[0]) < 0 or int(x[1]) < 0:                successful = False                error_loc = 'lose a turn'        elif lose_turn != 'NO':            successful = False            error_loc = 'lose a turn'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                                 1            2              3                 4                5                   6                      7                    8                 9                   10            sql = ('INSERT INTO effectcond(guild_id, condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, val_removed, cause_lose_turn, condition_desc) VALUES(?,?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, type, turns, damage, cond_roll, gain_loss, effect_stat, value_effect, lose_turn, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()            await ctx.send(f'Condition {name} was successfully created')        else:            if successful == False:                await ctx.send(f'''Condition has failed in {error_loc} section.```create_cond_by_db [name] [type] [turns] [damage] [stat to break free] [gain or loss] [stat effected] [lose turn] [description]                ```where name is the name of the condition                where type is if the condition is physical or special                where turns is the number of turns effected as a dice                where damage is the damage dice                where stat to break free is the stat used to break free from the condition or NONE if not                where gain or loss if the condition give to the stat effected or removes from the stat effected                where stat effected is the stat effected by the condition                where lose turn if the condition causes the player to lose a turn                where description is the description of the condition                                for all but description please use double quotation marks ("") around the section if spaces are present''')            elif exists == True:                await ctx.send('A condition with that name does not exists! Please choose a different name!')    @create_cond_by_db.error    async def create_cond_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''An argument is missing from the command or incorrectly formatted!            ```create_cond_by_db [name] [type] [turns] [damage] [stat to break free] [gain or loss] [stat effected] [lose turn] [description]```            where name is the name of the condition            where type is if the condition is physical or special            where turns is the number of turns effected as a dice            where damage is the damage dice            where stat to break free is the stat used to break free from the condition or NONE if not            where gain or loss if the condition give to the stat effected or removes from the stat effected            where stat effected is the stat effected by the condition            where lose turn if the condition causes the player to lose a turn            where description is the description of the condition                        for all but description please use double quotation marks ("") around the section if spaces are present''')        else:            await ctx.send('An error has occurred!')    #show a condition    @commands.command()    async def show_condition(self, ctx, cond_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                              0            1              2                 3                       4                   5                      6                    7             8        cursor.execute(f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            await ctx.send(f'''{result[0]}            ```Type: {result[1]}            Turns Effected: {result[2]}            Damage: {result[3]}            Stat to break free: {result[4]}            Causes: {result[5]} in {result[6]}            Lose a turn?: {result[7]}                        Description:\n{result[8]}''')    @show_condition.error    async def show_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''An argument is missing from the command or incorrectly formatted!            ```show_condition [cond_name]```            where cond_name is the name of the condition                        for all but description please use double quotation marks ("") around the section if spaces are present''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_condition(self, ctx, cond_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                              0            1              2                 3                       4                   5                      6                    7             8               9        cursor.execute(f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, val_removed, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        last_val = cursor.fetchone()        accepted_strings = ['name', 'type', 'turns', 'damage', 'stat_free', 'gain_loss', 'stat_effected', 'val_changed', 'lose_turn', 'desc']        if last_val is None:            await ctx.send(f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            if info in accepted_strings:                if info == accepted_strings[0]:                    sql = ('UPDATE effectcond SET condition_name = ? WHERE guild_id = ? AND condition_name = ?')                    val = (value, ctx.guild.id, cond_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == accepted_strings[1]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        sql = ('UPDATE effectcond SET condition_type = ? WHERE guild_id = ? AND condition_name = ?')                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value was not acceptable, the value is staying as it was!')                elif info == accepted_strings[2]:                    if value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                sql = ('UPDATE effectcond SET condition_turns = ? WHERE guild_id = ? AND condition_name = ?')                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send('The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send('The dice format must be XdY where X is number of dice and Y is the max value of the dice!')                elif info == accepted_strings[3]:                    if value == 'None':                        sql = ('UPDATE effectcond SET condition_damage = ? WHERE guild_id = ? AND condition_name = ?')                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                sql = ('UPDATE effectcond SET condition_damage = ? WHERE guild_id = ? AND condition_name = ?')                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send(                                'The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send(                            'The dice format must be XdY where X is number of dice and Y is the max value of the dice or the value must be NONE!')                elif info == accepted_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    result = cursor.fetchone()                    if value == result[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat1", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat2", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat3", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat4", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat5", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat6", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == 'NONE':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("None", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is not acceptable. The value will stay the same!')                elif info == accepted_strings[5]:                    if value == 'GAIN' or value == 'LOSS':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_gain_loss = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value was not GAIN or LOSS and will stay the same!')                elif info == accepted_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    result = cursor.fetchone()                    if value == result[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat1", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat2", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat3", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat4", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat5", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat6", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == 'NONE':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("None", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is not acceptable. The value will stay the same!')                elif info == accepted_strings[7]:                    if can_be_int(value):                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET val_removed = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is not acceptable. The value will stay the same!')                elif info == accepted_strings[8]:                    if value == 'NO':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET cause_lose_turn = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                db = sqlite3.connect('main.sqlite')                                cursor = db.cursor()                                sql = (                                    "UPDATE effectcond SET cause_lose_turn = ? WHERE guild_id = ? AND condition_name = ?")                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send(                                    'The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send(                                'The dice format must be XdY where X is number of dice and Y is the max value of the dice or the value must be NO!')                elif info == accepted_strings[9]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE effectcond SET condition_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, cond_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The command has an incorrect argument!                    ```update_condition [cond_name] [info] [value]                    where cond_name is the name of the condition                    where info is one of the acceptable strings name to change the name, type to change the type of the condition, turns to change the number of turns, damage to change the damage dice, stat_free to change the stat added to break free, gain_loss to change if the effect add or removes from the effected stat, stat_effected to show the effected stat, val_changed to change the value gained or lost, lose_turn to change if they lose a turn or the dice equal to the number of turns, desc to change the description                    where value is the value of the data```''')    @update_condition.error    async def update_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!                                ```update_condition [cond_name] [info] [value]                                where cond_name is the name of the condition                                where info is one of the acceptable strings name to change the name, type to change the type of the condition, turns to change the number of turns, damage to change the damage dice, stat_free to change the stat added to break free, gain_loss to change if the effect add or removes from the effected stat, stat_effected to show the effected stat, val_changed to change the value gained or lost, lose_turn to change if they lose a turn or the dice equal to the number of turns, desc to change the description                                where value is the value of the data```''')        else:            await ctx.send('An odd error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_condition(self, ctx, cond_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        last_val = cursor.fetchone()        if last_val is None:            await ctx.send(                f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM effectcond WHERE guild_id = ? AND condition_name = ?')            val = (ctx.guild.id, cond_name)            db.commit()            cursor.close()            db.close()            await ctx.send(f'Deleted {cond_name}')    @delete_condition.error    async def delete_cond_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!            ```delete_condition [cond_name]            where cond_name is the name of the condition```''')        else:            await ctx.send('An error has occurred!')    ####################################################################################################################    #   Abilities                                                                                                      #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_ability_by_db(self, ctx, name, type, range, cond, *, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        successful = True        error_loc = ''        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'Ability Type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'Ability Range'        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')        last_val = cursor.fetchone()        if last_val is None:            successful = False            error_loc = 'Assigning Conditions'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('INSERT INTO abilities(guild_id, ability_name, ability_type, buff_range, buff_condition, ability_desc) VALUES(?,?,?,?,?,?)')            val = (ctx.guild.id, name, type, range, cond, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''An error occurred in {error_loc}!                ```create_ability_by_db [name] [type] [range] [cond] [desc]                where name is the name of the ability                where type is the type of the ability                where range is if it effects the player character or the other player's character                where cond is the condition associated with the ability                where desc is equal to the description of the class                                If you are putting a space in anything but the description, please surround it in double quotes ("").''')            elif exists:                await ctx.send('An ability with this name already exists! Please try again!')    @create_ability_by_db.error    async def create_ability_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''An command is missing an argument!            ```create_ability_by_db [name] [type] [range] [cond] [desc]            where name is the name of the ability            where type is the type of the ability            where range is if it effects the player character or the other player's character            where cond is the condition associated with the ability            where desc is equal to the description of the class                        If you are putting a space in anything but the description, please surround it in double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_ability(self, ctx, ability_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {ability_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {ability_name} does not exist! If the name has a space, please surround the data with double quotes ("").')        else:            await ctx.send(f'''{result[0]}            ```Type: {result[1]}            Effects: {result[2]}            Condition Given:{result[3]}            Description:\n{result[4]}''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_ability(self, ctx, abil_name, info, *, value):        acceptable_strings = ['name', 'type', 'range', 'cond', 'desc']        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {abil_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {abil_name} does not exist! If the name has a space, please surround the data with double quotes ("").')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE abilities SET ability_type = ? WHERE guild_id = ? AND ability_name = ?")                    val = (value, ctx.guild.id, abil_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    if value == "PHYSICAL" or value == "SPECIAL":                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET ability_type = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is incorrect, the value will return to the previous value!')                elif info == acceptable_strings[2]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET buff_range = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[3]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    last_val = cursor.fetchone()                    if last_val is None:                        await ctx.send('The value entered is not a condition. The value is going to stay the same!')                    else:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET buff_condition = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE abilities SET ability_desc = ? WHERE guild_id = ? AND ability_name = ?")                    val = (value, ctx.guild.id, abil_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send(f'''The value you inputted was not acceptable!                    ```update_ability [abil_name] [info] [value]                    where abil_name is the ability name                    where info is the thing to change                    where value is the new value```''')            else:                await ctx.send(f'''The value you inputted was not acceptable!                ```update_ability [abil_name] [info] [value]                where abil_name is the ability name                where info is the thing to change                where value is the new value```''')    @update_ability.error    async def update_ability_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```update_ability [abil_name] [info] [value]            where abil_name is the ability name            where info is the thing to change            where value is the new value```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_ability(self, ctx, abil_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {abil_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {abil_name} does not exist!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql  = ('DELETE FROM abilities WHERE ability_name = ? AND guild_id = ?')            val = (abil_name, ctx.guild.id)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @delete_ability.error    async def delete_ability_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing arguments!            ```delete_ability [abil_name]            where abil_name is the name of the ability```                        If the name has a space, pleasse use double quotes ("") around the name.''')    ####################################################################################################################    #   Spells                                                                                                         #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_spell_attack(self, ctx, name, stat_used, type, range, damage, save, *, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        successful = True        error_loc = ''        if stat_used not in stats:            successful = False            error_loc = 'getting stat used to cast'        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'setting type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'setting range'        if damage.find('d') == -1:            successful = False            error_loc = 'setting damage'        elif damage.find('d') != -1:            x = damage.split('d')            if can_be_int(x[0]) and can_be_int(x[1]):                if int(x[0]) < 0 or int(x[1]) < 0:                    successful = False                    error_loc = 'setting damage'            else:                successful = False                error_loc = 'setting damage'        elif damage != 'NONE':            successful = False            error_loc = 'setting damage'        if save not in stats or save != 'NONE':            successful = False            error_loc = 'getting stat used to cast'        if successful and exists == False:            if stat_used == stats[0]:                stat_to_cast = 'stat1'            elif stat_used == stats[1]:                stat_to_cast = 'stat2'            elif stat_used == stats[2]:                stat_to_cast = 'stat3'            elif stat_used == stats[3]:                stat_to_cast = 'stat4'            elif stat_used == stats[4]:                stat_to_cast = 'stat5'            elif stat_used == stats[5]:                stat_to_cast = 'stat6'            if save == stats[0]:                stat_to_save = 'stat1'            elif save == stats[1]:                stat_to_save = 'stat2'            elif save == stats[2]:                stat_to_save = 'stat3'            elif save == stats[3]:                stat_to_save = 'stat4'            elif save == stats[4]:                stat_to_save = 'stat5'            elif save == stats[5]:                stat_to_save = 'stat6'            elif save == 'NONE':                stat_to_save = 'NONE'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                              1           2        3            4            5            6             7            8              9                  10            sql = ('INSERT INTO spells(guild_id, spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc) VALUES(?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, 'ATTACK', stat_to_cast, type, range, damage, stat_to_save, 'NONE', desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''The command failed at {error_loc}!                 ```create_spell_attack [name] [stat_used] [type] [range] [damage] [save] [desc]                where name is the name of the spell                where stat_used is the name of the stat added to cast                where type is the type of spell                where range is if it effects the user or the enemy                where damage is the damage of the spell                where save is the stat used to save against the spell                where desc is the description of the spell```                                If one of the values contains a space outside of the description, then surround the value by double quotes ("").''')            elif exists:                await ctx.send('A spell with that name exists! Please choose a different name!')    @create_spell_attack.error    async def create_spell_attack_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing arguments!            ```create_spell_attack [name] [stat_used] [type] [range] [damage] [save] [desc]            where name is the name of the spell            where stat_used is the name of the stat added to cast            where type is the type of spell            where range is if it effects the user or the enemy            where damage is the damage of the spell            where save is the stat used to save against the spell            where desc is the description of the spell```                        If one of the values contains a space outside of the description, then surround the value by double quotes ("").''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_spell_buff(self, ctx, name, stat_uses, type, range, save, buff_debuff_cond, *, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        successful = True        error_loc = ''        if stat_uses not in stats:            successful = False            error_loc = 'getting stat used to cast'        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'setting type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'setting range'        if save not in stats or save != 'NONE':            successful = False            error_loc = 'getting stat used to cast'        cursor.execute(f'SELECT condition_name FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {buff_debuff_cond}')        cond = cursor.fetchone()        if cond is None:            successful = False            error_loc = 'setting condition'        if successful and exists == False:            if stat_uses == stats[0]:                stat_to_cast = 'stat1'            elif stat_uses == stats[1]:                stat_to_cast = 'stat2'            elif stat_uses == stats[2]:                stat_to_cast = 'stat3'            elif stat_uses == stats[3]:                stat_to_cast = 'stat4'            elif stat_uses == stats[4]:                stat_to_cast = 'stat5'            elif stat_uses == stats[5]:                stat_to_cast = 'stat6'            if save == stats[0]:                stat_to_save = 'stat1'            elif save == stats[1]:                stat_to_save = 'stat2'            elif save == stats[2]:                stat_to_save = 'stat3'            elif save == stats[3]:                stat_to_save = 'stat4'            elif save == stats[4]:                stat_to_save = 'stat5'            elif save == stats[5]:                stat_to_save = 'stat6'            elif save == 'NONE':                stat_to_save = 'NONE'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('INSERT INTO spells(guild_id, spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc) VALUES(?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, 'BUFF', stat_to_cast, type, range, 'NONE', stat_to_save, buff_debuff_cond, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send('''The command has an error in it!                ```create_spell_buff [name] [stat_used] [type] [range] [save] [buff_debuff_cond] [desc]                where name is the name of the spell                where stat_used is the stat used to cast the spell                where type is the type of the move                where range is if the spell effects the user or the enemy                where save is the stat added to save against the stat                where buff_debuff_cond is the condition for the buff or debuff                where desc is the description of the spell```                                If there is a space in any of those values except for description, surround the value with double quotes ("").''')            elif exists:                await ctx.send('A spell with that name already exists. Please pick a different name!')    @create_spell_buff.error    async def create_spell_buff_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing parameters!                           ```create_spell_buff [name] [stat_used] [type] [range] [save] [buff_debuff_cond] [desc]                           where name is the name of the spell                           where stat_used is the stat used to cast the spell                           where type is the type of the move                           where range is if the spell effects the user or the enemy                           where save is the stat added to save against the stat                           where buff_debuff_cond is the condition for the buff or debuff                           where desc is the description of the spell```                                                      If there is a space in any of those values except for description, surround the value with double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_spell(self, ctx, *, spell_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'''The spell {spell_name} does not exist!            ```show_spell [spell_name]            where spell_name is the name of the spell```''')        else:            cursor.execute(                f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')            stats = cursor.fetchone()            if result[2] == stats[0]:                casting = 'stat1'            elif result[2] == stats[1]:                casting = 'stat2'            elif result[2] == stats[2]:                casting = 'stat3'            elif result[2] == stats[3]:                casting = 'stat4'            elif result[2] == stats[4]:                casting = 'stat5'            elif result[2] == stats[5]:                casting = 'stat6'            if result[6] == stats[0]:                stat_to_save = 'stat1'            elif result[6] == stats[1]:                stat_to_save = 'stat2'            elif result[6] == stats[2]:                stat_to_save = 'stat3'            elif result[6] == stats[3]:                stat_to_save = 'stat4'            elif result[6] == stats[4]:                stat_to_save = 'stat5'            elif result[6] == stats[5]:                stat_to_save = 'stat6'            elif result[6] == 'NONE':                stat_to_save = 'NONE'            if result[1] == 'ATTACK':                await ctx.send(f'''{result[0]} : {result[1]}                ```Spell adds {casting} to the spell roll                Type: {result[3]}                Range: {result[4]}                Damage: {result[5]}                Save: {stat_to_save}                                Description:\n{result[8]}''')            elif result[1] == 'BUFF':                await ctx.send(f'''{result[0]} : {result[1]}                ```Spell adds {casting} to the spell roll                Type: {result[3]}                Range: {result[4]}                Condition: {result[7]}                Save: {stat_to_save}                                Description:\n{result[8]}''')    @show_condition.error    async def show_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```show_spell [spell_name]            where spell_name is the name of the spell```''')    @commands.command()    @commands.has_guild_permissions(administrator = True)    async def update_attack_spell(self, ctx, spell_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        acceptable_strings = ['name', 'stat_used', 'type', 'range', 'damage', 'save', 'desc']        if result is None:            await ctx.send(f'''This spell does not exist!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, damage, save, and desc```''')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_name = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[2]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_type = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not PHYSICAL or SPECIAL. Keeping it the same!')                elif info == acceptable_strings[3]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_range = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not SELF or ENEMY. Keeping it the same!')                elif info == acceptable_strings[4]:                    if value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                db = sqlite3.connect('main.sqlite')                                cursor = db.cursor()                                sql = (                                    "UPDATE spells SET spell_damage = ? WHERE guild_id = ? AND condition_name = ?")                                val = (value, ctx.guild.id, spell_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The value XdY contains a value not greater than one. X is the number of dice and Y is the max dice value! The value will remain the same as before!')                        else:                            await ctx.send('The value XdY contains a value that is not an int. X is the number of dice and Y is the max dice value! The value will remain the same as before!')                    else:                        await ctx.send('The must be in  XdY form where X is the number of dice and Y is the max dice value! The value will remain the same as before!')                elif info == acceptable_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = ('stat6', ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The value you want to change is not acceptable!                    ```update_attack_spell [spell_name] [info] [value]                    where spell_name is the name of the spell you are looking for                    where info is the info you want to changes                    where value is the value to set the info to                    the values that info can be are name, stat_used, type, range, damage, save, and desc```''')            else:                await ctx.send('''The value you want to change is not acceptable!                ```update_attack_spell [spell_name] [info] [value]                where spell_name is the name of the spell you are looking for                where info is the info you want to changes                where value is the value to set the info to                the values that info can be are name, stat_used, type, range, damage, save, and desc```''')    @update_attack_spell.error    async def update_attack_spell(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an appropriate value!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, damage, save, and desc```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_buff_spell(self, ctx, spell_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        acceptable_strings = ['name', 'stat_used', 'type', 'range', 'condition', 'save', 'desc']        if result is None:            await ctx.send(f'''This spell does not exist!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, condition, save, and desc```''')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_name = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[2]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_type = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not PHYSICAL or SPECIAL. Keeping it the same!')                elif info == acceptable_strings[3]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_range = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not SELF or ENEMY. Keeping it the same!')                elif info == acceptable_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    cond = cursor.fetchone()                    if cond is None:                        await ctx.send('The condition does not exist! Keeping the value the same!')                    else:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET buff_debuff_condition = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = ('stat6', ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The value you want to change is not acceptable!                    ```update_attack_spell [spell_name] [info] [value]                    where spell_name is the name of the spell you are looking for                    where info is the info you want to changes                    where value is the value to set the info to                    the values that info can be are name, stat_used, type, range, condition, save, and desc```''')            else:                await ctx.send('''The value you want to change is not acceptable!                ```update_attack_spell [spell_name] [info] [value]                where spell_name is the name of the spell you are looking for                where info is the info you want to changes                where value is the value to set the info to                the values that info can be are name, stat_used, type, range, condition, save, and desc```''')    @update_buff_spell.error    async def update_attack_spell(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an appropriate value!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, condition, save, and desc```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_spell(self, ctx, spell_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'''The spell {spell_name} does not exist!            ```delete_spell [spell_name]            where spell_name is the name of the spell```''')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM spells WHERE spell_name = ? AND guild_id = ?')            val = (spell_name, ctx.guild.id)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    ####################################################################################################################    #   Races                                                                                                          #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_race_by_db(self, ctx, name, set_hp, set_mp, set_ep, stat_list_plus_min, cond_immune_list, cond_resist_list, cond_vulnerable_list, ability_list, *, desc):        exists = False        successful = True        error_loc = ''        cond_immune_str = ''        cond_immune_failed = ''        cond_resist_str = ''        cond_resist_failed = ''        cond_vulnerable_str = ''        cond_vulnerable_failed = ''        ability_str = ''        ability_failed = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        if not can_be_int(set_hp):            successful = False            error_loc = 'setting hp'        elif can_be_int(set_hp):            if int(set_hp) < 0:                successful = False                error_loc = 'setting hp'        if not can_be_int(set_mp):            successful = False            error_loc = 'setting mp'        elif can_be_int(set_mp):            if int(set_mp) < 0:                successful = False                error_loc = 'setting mp'        if not can_be_int(set_ep):            successful = False            error_loc = 'setting ep'        elif can_be_int(set_ep):            if int(set_ep) < 0:                successful = False                error_loc = 'setting ep'        if stat_list_plus_min.find(',') == -1:            successful = False            error_loc = 'setting the add and subtract values of stats'        elif stat_list_plus_min.find(',') != -1:            x = stat_list_plus_min.split(',')            if len(x) != 6:                successful = False                error_loc = 'setting the add and subtract values of stats'            elif not can_list_be_int(x):                successful = False                error_loc = 'setting the add and subtract values of stats'        if cond_immune_list.find(',') == -1:            if cond_immune_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_immune_list}')                res = cursor.fetchone()                if res is None:                    cond_immune_str == 'NONE'        elif cond_immune_list.find(',') != -1:            x = cond_immune_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_immune_str += f'{cond},'                else:                    cond_immune_failed += f'{cond},'            cond_immune_str.rstrip(',')            cond_immune_failed.rstrip(',')            if cond_immune_str == '':                cond_immune_str == 'NONE'            await ctx.send(f'{cond_immune_failed} failed to add')        else:            cond_immune_str == 'NONE'        if cond_resist_list.find(',') == -1:            if cond_resist_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_resist_list}')                res = cursor.fetchone()                if res is None:                    cond_resist_str == 'NONE'        elif cond_resist_list.find(',') != -1:            x = cond_resist_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_resist_str += f'{cond},'                else:                    cond_resist_failed += f'{cond},'            cond_resist_str.rstrip(',')            cond_resist_failed.rstrip(',')            if cond_resist_str == '':                cond_resist_str == 'NONE'            await ctx.send(f'{cond_resist_failed} failed to add')        else:            cond_resist_str == 'NONE'        if cond_vulnerable_list.find(',') == -1:            if cond_vulnerable_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_vulnerable_list}')                res = cursor.fetchone()                if res is None:                    cond_vulnerable_str == 'NONE'        elif cond_vulnerable_list.find(',') != -1:            x = cond_vulnerable_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_vulnerable_str += f'{cond},'                else:                    cond_vulnerable_failed += f'{cond},'            cond_vulnerable_str.rstrip(',')            cond_vulnerable_failed.rstrip(',')            if cond_vulnerable_str == '':                cond_vulnerable_str == 'NONE'            await ctx.send(f'{cond_vulnerable_failed} failed to add')        else:            cond_vulnerable_str == 'NONE'        if ability_list.find(',') == -1:            if ability_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {ability_list}')                res = cursor.fetchone()                if res is not None:                    ability_str = ability_list                else:                    ability_str = 'NONE'        elif ability_list.find(',') != -1:            x = ability_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {cond}')                res = cursor.fetchone()                if res is not None:                    ability_str += f'{cond},'                else:                    ability_failed += f'{cond},'            ability_str.rstrip(',')            ability_failed.rstrip(',')            if ability_str == '':                ability_str == 'NONE'            await ctx.send(f'{ability_failed} failed to add')        else:            ability_str = 'NONE'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                               1     2            3      4        5          6            7                    8                  9                     10               11            sql = ('INSERT INTO spells(guild_id, race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description) VALUES(?,?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, set_hp, set_mp, set_ep, stat_list_plus_min, cond_immune_str, cond_resist_str, cond_vulnerable_str, ability_str, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''The creator failed at {error_loc}.                ```create_race_by_db [name] [set_hp] [set_mp] [set_ep] [stat_list_plus_min] [cond_immune_list] [cond_resist_list] [cond_vulnerable_list] [ability_list] [desc]                where name is the name of the race                where set_hp is the value to set the hp to                where set_mp is the value to set the mp to                where set_ep is the value to set the ep to                where stat_list_plus_min is the values of each stat separated by commas                where cond_immune_list is the value of all immunities separated by commas                where cond_resist_list is the value of all resistances separated by commas                where cond_vulnerable_list is the value of all vulnerabilities separated by commas                where ability_list is the value of all abilities separated by commas```                                If a value has a space in it, please surround it with double quotes ("").''')            elif exists:                await ctx.send('The race already has that name! Please select a different name!')    @create_race_by_db.error    async def create_race_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing an argument!            ```create_race_by_db [name] [set_hp] [set_mp] [set_ep] [stat_list_plus_min] [cond_immune_list] [cond_resist_list] [cond_vulnerable_list] [ability_list] [desc]                where name is the name of the race                where set_hp is the value to set the hp to                where set_mp is the value to set the mp to                where set_ep is the value to set the ep to                where stat_list_plus_min is the values of each stat separated by commas                where cond_immune_list is the value of all immunities separated by commas                where cond_resist_list is the value of all resistances separated by commas                where cond_vulnerable_list is the value of all vulnerabilities separated by commas                where ability_list is the value of all abilities separated by commas```                                If a value has a space in it, please surround it with double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_race(self, ctx, *, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        hp = get_val_from_json(ctx, 'hp.json')        mp = get_val_from_json(ctx, 'mp.json')        ep = get_val_from_json(ctx, 'ep.json')        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        if result[4].find(',') != -1:            x = result[4].split(',')        y = result[5].replace(',', ' ')        z = result[6].replace(',', ' ')        j = result[7].replace(',', ' ')        k = result[8].replace(',', ' ')        if result is None:            await ctx.send(f'{name} is not a race!')        else:            await ctx.send(f'''{result[0]}            ```{hp}: {result[1]}   {mp}: {result[2]}   {ep}: {result[3]}            {stats[0]}: {x[0]}   {stats[1]}: {x[1]}   {stats[2]}: {x[2]}   {stats[3]}: {x[3]}   {stats[4]}: {x[4]}   {stats[5]}: {x[5]}            Conditions Immune:\n{y}            Conditions Resistant:\n{z}            Conditions Vulnerable:\n{j}            Abilities:\n{k}                        Description:\n{result[9]}''')    @show_condition.error    async def show_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!            ```show_race [name]            where name is the name of the race```''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_race(self, ctx, name, info, *, value):        #                      0        1         2         3              4                5                  6               7                 8                     9                 10                          11          12             13        accepted_strings = ['name', 'set_hp', 'set_mp', 'set_ep', 'change_stat_list', 'add_immunity', 'remove_immunity', 'add_resistance', 'remove_resistance', 'add_vulnerability', 'remove_vulnerability', 'add_ability', 'remove_ability', 'desc']        insert_col = ''        insert_val = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                           0          1     2        3         4                 5                  6                  7                   8               9        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The race name does not exist!')        else:            if info in accepted_strings:                if info == accepted_strings[0]:                    insert_col = 'race_name'                    insert_val = value                elif info == accepted_strings[1]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_hp'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[2]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_mp'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[3]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_ep'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[4]:                    if value.find(',') != -1:                        x = value.split(',')                        if len(x) == 6 and can_list_be_int(x):                            insert_col = 'stats_plus_min'                            insert_val = value                        elif len(x) != 6:                            await ctx.send(f'THe list is to small! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        elif not can_list_be_int(x):                            await ctx.send(f'The value does not contain integers! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        else:                            await ctx.send(f'There is an unknown error with this list! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                    else:                        await ctx.send(                            f'The value is in an incorrect form! The current list is {result[4]}! Please manipulate these values and paste in this format!')                        return                elif info == accepted_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[5]                        if x != 'NONE':                            x += f',{value}'                        else:                            x = f'{value}'                        insert_col = 'condtion_immune'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[5]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        if x == '':                            x = 'NONE'                        insert_col = 'condtion_immune'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[7]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[6]                        if x != 'NONE':                            x += f',{value}'                        else:                            x = f'{value}'                        insert_col = 'condtition_strength'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[8]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[6]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        if x == '':                            x = 'NONE'                        insert_col = 'condtition_strength'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[9]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[7]                        if x != 'NONE':                            x += f',{value}'                        else:                            x = f'{value}'                        insert_col = 'condition_vulnerable'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[10]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[7]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        if x == '':                            x = 'NONE'                        insert_col = 'condition_vulnerable'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[11]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        if x != 'NONE':                            x += f',{value}'                        else:                            x = f'{value}'                        insert_col = 'ability_list'                        insert_val = x                    else:                        await ctx.send('This ability does not exist!')                        return                elif info == accepted_strings[12]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        if x == '':                            x = 'NONE'                        insert_col = 'ability_list'                        insert_val = x                    else:                        await ctx.send('This ability does not exist!')                        return                elif info == accepted_strings[13]:                    insert_col = 'race_description'                    insert_val = value                else:                    await ctx.send(f'''The value entered does not match the one of the acceptable values!                    ```update_race [name] [info] [value]                    where name is the name of the race                    where info is the info you want to change                        The acceptable values are                            name to change the name of the race                            set_hp to set the hp value of the race                            set_mp to set the mp value of the race                            set_ep to set the ep value of the race                            change_stat_list to change the list of what is added or removed from a stat                            add_immunity to add a condition the race is immune to                            remove_immunity to remove a condition the race is immune to                            add_resistance to add a condition the race is resistant to                            remove_resistance to remove a condition the race is resistant to                            add_vulnerability to add a condition the race is vulnerable to                            remove_vulnerability to remove a condition the race is vulnerable to                            add_ability to add an ability the race has                            remove_ability to remove an ability the race has                            desc to change the race description                    where the value is the value of the info you want to change```''')                    return                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                sql = (f'UPDATE races SET {insert_col} = ? WHERE guild_id = ? AND race_name = ?')                val = (insert_val, ctx.guild.id, name)                cursor.execute(sql, val)                db.commit()                cursor.close()                db.close()            else:                await ctx.send(f'''The value entered does not match the one of the acceptable values!                ```update_race [name] [info] [value]                where name is the name of the race                where info is the info you want to change                    The acceptable values are                        name to change the name of the race                        set_hp to set the hp value of the race                        set_mp to set the mp value of the race                        set_ep to set the ep value of the race                        change_stat_list to change the list of what is added or removed from a stat                        add_immunity to add a condition the race is immune to                        remove_immunity to remove a condition the race is immune to                        add_resistance to add a condition the race is resistant to                        remove_resistance to remove a condition the race is resistant to                        add_vulnerability to add a condition the race is vulnerable to                        remove_vulnerability to remove a condition the race is vulnerable to                        add_ability to add an ability the race has                        remove_ability to remove an ability the race has                        desc to change the race description                where the value is the value of the info you want to change```''')                return    @update_race.error    async def update_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```update_race [name] [info] [value]            where name is the name of the race            where info is the info you want to change                The acceptable values are                    name to change the name of the race                    set_hp to set the hp value of the race                    set_mp to set the mp value of the race                    set_ep to set the ep value of the race                    change_stat_list to change the list of what is added or removed from a stat                    add_immunity to add a condition the race is immune to                    remove_immunity to remove a condition the race is immune to                    add_resistance to add a condition the race is resistant to                    remove_resistance to remove a condition the race is resistant to                    add_vulnerability to add a condition the race is vulnerable to                    remove_vulnerability to remove a condition the race is vulnerable to                    add_ability to add an ability the race has                    remove_ability to remove an ability the race has                    desc to change the race description                where the value is the value of the info you want to change```''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_race(self, ctx, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The race {name} is not a current race!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM races WHERE guild_id = ? AND race_name = ?')            val = (ctx.guild.id, name)            db.commit()            cursor.close()            db.close()    @delete_race.error    async def delete_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```delete_race [name]            where name is the race name```''')        else:            await ctx.send('An error has occurred!')    ####################################################################################################################    #   Classes                                                                                                        #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_class_by_db(self, ctx, name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage,                                 spell_array, start_weapon, start_armor, start_potion, *, class_desc):        exists = False        successful = True        error_loc = ''        spell_list_str = ''        spell_list_fail = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, class_ac_roll_stat, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {name}')        last_val = cursor.fetchone()        if last_val is not None:            exists = True        else:            if not can_be_int(add_sub_hp):                successful = False                error_loc = 'setting the value to add/subtract from hp'            if not can_be_int(add_sub_mp):                successful = False                error_loc = 'setting the value to add/subtract from mp'            if not can_be_int(add_sub_ep):                successful = False                error_loc = 'setting the value to add/subtract from ep'            if stats_plus_min.find(',') == -1:                successful = False                error_loc = 'setting the add and subtract values of stats'            elif stats_plus_min.find(',') != -1:                x = stats_plus_min.split(',')                if len(x) != 6:                    successful = False                    error_loc = 'setting the add and subtract values of stats'                elif can_list_be_int(x):                    successful = False                    error_loc = 'setting the add and subtract values of stats'            if not can_be_int(stat_spell_save):                successful = False                error_loc = 'setting the spell/energy move value to compete against'            elif not can_be_int(stat_spell_save):                if int(stat_spell_save) < 0:                    successful = False                    error_loc = 'setting the spell/energy move value to compete against'            if unarmed_attack_damage.find('d') != -1:                x = unarmed_attack_damage.split('d')                if not can_be_int(x[0]) or not can_be_int(x[1]):                    successful = False                    error_loc = 'setting unarmed hit dice'                elif can_be_int(x[0]) and can_be_int(x[1]):                    if int(x[0]) < 0 and int(x[1]) < 0:                        successful = False                        error_loc = 'setting unarmed hit dice'            if spell_array.find(',') == -1:                if spell_array != 'NONE':                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT spell_name FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_array}')                    res = cursor.fetchone()                    if res is not None:                        spell_list_str = spell_array                    else:                        spell_list_str = 'NONE'            elif spell_array.find(',') != -1:                x = spell_array.split(',')                for cond in x:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT spell_name FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_array}')                    res = cursor.fetchone()                    if res is not None:                        spell_list_str += f'{cond},'                    else:                        spell_list_fail += f'{cond},'                spell_list_str.rstrip(',')                spell_list_fail.rstrip(',')                if spell_list_str == '':                    spell_list_str == 'NONE'                await ctx.send(f'{spell_list_fail} failed to add')            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            cursor.execute(                f'SELECT weapon_name FROM weapons WHERE guild_id = {ctx.guild.id} AND weapon_name = {start_weapon}')            start_weap = cursor.fetchone()            if start_weap is None:                successful = False                error_loc = 'setting starting weapon'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            cursor.execute(                f'SELECT armor_name FROM armors WHERE guild_id = {ctx.guild.id} AND armor_name = {start_armor}')            start_arm = cursor.fetchone()            if start_arm is None:                successful = False                error_loc = 'setting starting armor'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            cursor.execute(                f'SELECT potion_name FROM potions WHERE guild_id = {ctx.guild.id} AND potion_name = {start_potion}')            start_pot = cursor.fetchone()            if start_pot is None:                successful = False                error_loc = 'setting starting potion'            if successful and not exists:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                #                              1          2            3        4             5            6              7                 8                    9              10                11              12           13         14                sql = ('INSERT INTO spells(guild_id, class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, class_ac_roll_stat, start_weapon, start_armor, start_items, class_desc) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?)')                val = (ctx.guild.id, name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage,                                 spell_list_str, start_weapon, start_armor, start_potion, class_desc)                cursor.execute(sql, val)                db.commit()                cursor.close()                db.close()            else:                if not successful:                    await ctx.send(f'''There was an error at {error_loc}!                    ```create_class_by_db [name] [add_sub_hp] [add_sub_mp] [add_sub_ep] [stats_plus_min] [stat_spell_save] [unarmed_attack_damage] [spell_array] [start_weapon] [start_armor] [start_potion] [class_desc]                    where name is the name of the class                    where add_sub_hp is the value added or subtracted from hp                    where add_sub_np is the value added or subtracted from mp                    where add_sub_ep is the value added or subtracted from ep                    where stats_plus_min is the six values added and subtracted from stats                    where stat_spell_save is the value to beat when a player with this class casts a spell                    where unarmed_attack_damage is the damage of an unarmed attack                    where spell_array is the list of spells                    where start_weapon is the weapon the class starts with                    where start_armor is the armor the class starts with                    where start_potion is the potion the class starts with                    where class_desc is the class description```                                        If your values contain a space barring class_desc, surround those values with double quotes ("")!''')                elif exists:                    await ctx.send(f'''The class already exists! Please pick a different name!''')    @create_class_by_db.error    async def create_class_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''Your command is missing a required argument!            ```create_class_by_db [name] [add_sub_hp] [add_sub_mp] [add_sub_ep] [stats_plus_min] [stat_spell_save] [unarmed_attack_damage] [spell_array] [start_weapon] [start_armor] [start_potion] [class_desc]            where name is the name of the class            where add_sub_hp is the value added or subtracted from hp            where add_sub_np is the value added or subtracted from mp            where add_sub_ep is the value added or subtracted from ep            where stats_plus_min is the six values added and subtracted from stats            where stat_spell_save is the value to beat when a player with this class casts a spell            where unarmed_attack_damage is the damage of an unarmed attack            where spell_array is the list of spells            where start_weapon is the weapon the class starts with            where start_armor is the armor the class starts with            where start_potion is the potion the class starts with            where class_desc is the class description```                        If your values contain a space barring class_desc, surround those values with double quotes ("")!''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_class(self, ctx, *, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                           0            1            2         3             4                5                 6                  7              8             9          10         11        cursor.execute(f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {name}')        results = cursor.fetchone()        hp = get_val_from_json(ctx, 'hp.json')        mp = get_val_from_json(ctx, 'mp.json')        ep = get_val_from_json(ctx, 'ep.json')        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        x = results[4].split(',')        y = results[7].replace(',', ' ')        if results is None:            await ctx.send('The class does not exist!')        else:            ctx.send(f'''{results[0]}            ```{hp}: {results[1]} | {mp}: {results[2]} | {ep}: {results[3]}            {stats[0]}: {x[0]} | {stats[1]}: {x[1]} | {stats[2]}: {x[2]} | {stats[3]}: {x[3]} | {stats[4]}: {x[4]} | {stats[5]}: {x[5]}            Spell Save: {results[5]}            Unarmed Attack Damage {results[6]}            Spells:\n{y}            Starting Weapon: {results[8]}            Starting Armor: {results[9]}            Starting Potion: {results[10]}                        Description:\n{results[11]}''')    @show_class.error    async def show_class_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```show_class [name]            where name is the name of the class```''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_class(self, ctx, name, info, *, value):        #                        0        1              2               3              4             5              6           7                8              9              10                11             12        acceptable_strings = ['name', 'add_sub_hp', 'add_sub_mp', 'add_sub_ep', 'stat_plus_min', 'stat_save', 'add_spell', 'remove_spell', 'unarmed_damage', 'start_weapon', 'start_armor', 'start_potion', 'class_desc']        insert_col = ''        insert_val = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                           0            1            2         3             4                5                 6                  7              8             9          10         11        cursor.execute(f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send('The class name does not exist!')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    insert_col = 'class_name'                    insert_val = value                elif info == acceptable_strings[1]:                    if can_be_int(value):                        insert_col = 'add_sub_hp'                        insert_val = value                    else:                        await ctx.send(f'The value is not an integer!')                elif info == acceptable_strings[2]:                    if can_be_int(value):                        insert_col = 'add_sub_mp'                        insert_val = value                    else:                        await ctx.send(f'The value is not an integer!')                elif info == acceptable_strings[3]:                    if can_be_int(value):                        insert_col = 'add_sub_ep'                        insert_val = value                    else:                        await ctx.send(f'The value is not an integer!')                elif info == acceptable_strings[4]:                    if value.find(',') != -1:                        x = value.split(',')                        if len(x) == 6 and can_list_be_int(x):                            insert_col = 'stats_plus_min'                            insert_val = value                        elif len(x) != 6:                            await ctx.send(                                f'THe list is to small! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        elif not can_list_be_int(x):                            await ctx.send(                                f'The value does not contain integers! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        else:                            await ctx.send(                                f'There is an unknown error with this list! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                    else:                        await ctx.send(                            f'The value is in an incorrect form! The current list is {result[4]}! Please manipulate these values and paste in this format!')                        return                elif info == acceptable_strings[5]:                    if can_be_int(value):                        if int(value) >= 0:                            insert_col = 'stat_spell_save'                            insert_val = value                        else:                            await ctx.send(f'This value must be positive!')                            return                    else:                        await ctx.send(f'This value must be an integer!')                        return                elif info == acceptable_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        if x != 'NONE':                            x += f',{value}'                        else:                            x = f'{value}'                        insert_col = 'spell_array'                        insert_val = x                    else:                        await ctx.send('This spell does not exist!')                        return                elif info == acceptable_strings[7]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        if x == '':                            x = 'NONE'                        insert_col = 'spell_array'                        insert_val = x                    else:                        await ctx.send('This spell does not exist!')                        return                elif info == acceptable_strings[8]:                    if value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]):                                insert_col = 'unarmed_attack_damage'                                insert_val = value                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                                return                        else:                            await ctx.send('The values of the number of dice and/or the max dice value must be integers.')                            return                    else:                        await ctx.send('The dice format must be XdY where X is number of dice and Y is the max value of the dice!')                        return                elif info == acceptable_strings[9]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT weapon_name FROM weapons WHERE guild_id = {ctx.guild.id} AND weapon_name = {value}')                    start_weap = cursor.fetchone()                    if start_weap is not None:                        insert_col = 'start_weapon'                        insert_val = value                    else:                        await ctx.send('The value is not an already made weapon!')                        return                elif info == acceptable_strings[10]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT armor_name FROM armors WHERE guild_id = {ctx.guild.id} AND armor_name = {value}')                    start_arm = cursor.fetchone()                    if start_arm is not None:                        insert_col = 'start_armor'                        insert_val = value                    else:                        await ctx.send('The value is not an already made armor!')                        return                elif info == acceptable_strings[11]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT potion_name FROM potions WHERE guild_id = {ctx.guild.id} AND potion_name = {value}')                    start_pot = cursor.fetchone()                    if start_pot is not None:                        insert_col = 'start_items'                        insert_val = value                    else:                        await ctx.send('The value is not an already made potion!')                        return                elif info == acceptable_strings[12]:                    insert_col = 'class_desc'                    insert_val = value                else:                    await ctx.send(f'''The info argument does not the match the list of accepted values!                    ```uodate_class [name] [info] [value]                    where name is the name of the class                    where info is the info you want to update                        The acceptable values are:                            name which is the name of the class                            add_sub_hp which is the value added or removed from hp                            add_sub_mp which is the value added or removed from mp                            add_sub_ep which is the value added or removed from ep                            stat_plus_min which is the string of six values that would be added or removed from the stats                            stat_save which is the value of the stats to save                            add_spell which adds a spell to the spell list                            remove_spell which removes a spell from the spell list                            unarmed_damage which marks the unarmed damage as a dice                            start_weapon is the weapon the class starts with                            start_armor which is the armor the class starts with                            start_potion which is the potion the class starts with                            class_desc is the description of the class                        where value is the value that you will change the info to```''')                    return            else:                await ctx.send(f'''The info argument does not the match the list of accepted values!                ```uodate_class [name] [info] [value]                where name is the name of the class                where info is the info you want to update                    The acceptable values are:                        name which is the name of the class                        add_sub_hp which is the value added or removed from hp                        add_sub_mp which is the value added or removed from mp                        add_sub_ep which is the value added or removed from ep                        stat_plus_min which is the string of six values that would be added or removed from the stats                        stat_save which is the value of the stats to save                        add_spell which adds a spell to the spell list                        emove_spell which removes a spell from the spell list                        unarmed_damage which marks the unarmed damage as a dice                        start_weapon is the weapon the class starts with                        start_armor which is the armor the class starts with                        start_potion which is the potion the class starts with                        class_desc is the description of the class                    where value is the value that you will change the info to```''')                return        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        sql = (f'UPDATE races SET {insert_col} = ? WHERE guild_id = ? AND race_name = ?')        val = (insert_val, ctx.guild.id, name)        cursor.execute(sql, val)        db.commit()        cursor.close()        db.close()    @update_class.error    async def update_class_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''This class is missing arguments!            ```uodate_class [name] [info] [value]                where name is the name of the class                where info is the info you want to update                    The acceptable values are:                        name which is the name of the class                        add_sub_hp which is the value added or removed from hp                        add_sub_mp which is the value added or removed from mp                        add_sub_ep which is the value added or removed from ep                        stat_plus_min which is the string of six values that would be added or removed from the stats                        stat_save which is the value of the stats to save                        add_spell which adds a spell to the spell list                        emove_spell which removes a spell from the spell list                        unarmed_damage which marks the unarmed damage as a dice                        start_weapon is the weapon the class starts with                        start_armor which is the armor the class starts with                        start_potion which is the potion the class starts with                        class_desc is the description of the class                    where value is the value that you will change the info to```''')        else:            await ctx.send('There was an error!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_class(self, ctx, *, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                           0            1            2         3             4                5                 6                  7              8             9          10         11        cursor.execute(f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {name}')        results = cursor.fetchone()        if results is None:            await ctx.send('The class does not exist!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM classes WHERE guild_id = ? AND class_name = ?')            val = (ctx.guild.id, name)            cursor.execute(sql, val)            db.commit()            cursor.execute()            db.close()    @delete_class.error    async def delete_class_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```delete_class [name]            where name is the name of the class```''')        else:            await ctx.send('An error has occurred!')    ####################################################################################################################    #   Characters                                                                                                     #    ####################################################################################################################    @commands.command()    async def create_character_by_db(self, ctx, name, class_name, race_name, stat_list, *, desc):        user = ctx.message.author.id        error_loc = ''        successful = True        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT COUNT(character_name) FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user}')        res1 = cursor.fetchone()        cursor.execute(f'SELECT num_char_allowed FROM rules WHERE guild_id = {ctx.guild.id}')        res2 = cursor.fetchone()        if res1 is not None:            if int(res1[0]) >= int(res2[0]):                successful = False                error_loc = 'The amount of characters you have exceeds the limit set by the rules!'        cursor.execute(f'SELECT character_name FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user} AND character_name = {name}')        res3 = cursor.fetchone()        if res3 is not None:            successful = False            error_loc = 'A character with this name already exists! Please pick a different name!'        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, class_ac_roll_stat, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {class_name}')        res4 = cursor.fetchone()        if res4 is None:            successful = False            error_loc = 'The class does not exist!'        cursor.execute(            f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {race_name}')        res5 = cursor.fetchone()        if res5 is None:            successful = False            error_loc = 'This race does not exist!'        if stat_list.find(',') == -1:            successful = False            error_loc = 'The list of stats are not in the proper format! Please use stat1,stat2,stat3,stat4,stat5,stat6.'        elif stat_list.find(',') != -1:            x = stat_list.split(',')            if len(x) != 6:                successful = False                error_loc = 'The list of stats are not in the proper format! Please use stat1,stat2,stat3,stat4,stat5,stat6.'            elif not can_list_be_int(x):                successful = False                error_loc = 'The list of stats does not have an int! Please use stat1,stat2,stat3,stat4,stat5,stat6.'            elif can_list_be_int(x):                for i in x:                    if int(i) <= 0:                        successful = False                        error_loc = 'The list of stats has a negative number!'        if successful:            num_char = {str((int(res1[0]) + 1)) if res1 is not None else "1"}            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            cursor.execute(                f'SELECT start_weapon, start_armor, start_items, FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {class_name}')            items = cursor.fetchone()            lvl_list = get_val_from_json('lvllist.json')            y = lvl_list.split(',')            lvl_one = y[0]            sql = ('INSERT INTO characters(guild_id, user_id, character_number, character_name, class_id, race_id, stat_list, weapon_id, armor_id, item_id_list, level, exp, character_desc) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, user, num_char, name, class_name, race_name, stat_list, items[0], items[1], items[2], "1", lvl_one, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        if not successful:            await ctx.send(f'''Error: {error_loc}!            ```create_character_by_db [name] [class_name] [race_name] [stat_list] [desc]            where name is the name of the character            where class_name is the class of that character            where race_name is the race of that character            where stat_list is the list of stats obtained            where desc is the description```            If anything but the description contains a space, please surround it in double quotes ("").''')    @create_character_by_db.error    async def create_character_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command was missing an argument!            ```create_character_by_db [name] [class_name] [race_name] [stat_list] [desc]            where name is the name of the character            where class_name is the class of that character            where race_name is the race of that character            where stat_list is the list of stats obtained            where desc is the description```                        If anything but the description contains a space, please surround it in double quotes ("").''')    @commands.command()    async def show_character(self, ctx, name, user : discord.User):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                             0            1          2        3         4          5          6           7      8       9        cursor.execute(f'SELECT character_name, class_id, race_id, stat_list, weapon_id, armor_id, item_id_list, level, exp, character_desc FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user.id} AND character_name = {name}')        result = cursor.fetchone()        x = result[3].split(',')        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        await ctx.send(f'''{result[0]} | Level: {result[7]} | EXP: {result[8]}        Class: {result[1]} | Race: {result[2]}        Stats:\n{stats[0]}: {x[0]} | {stats[1]}: {x[1]} | {stats[2]}: {x[2]} | {stats[3]}: {x[3]} | {stats[4]}: {x[4]} | {stats[5]}: {x[5]}        Weapon: {result[4]} | Armor: {result[5]} | Potion: {result[6]}        Profile:\n{result[9]}''')    @show_character.error    async def show_character_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''There are missing arguments!            ```show_character [name] [user]            where name is the name of the character            where user is the mention of the user of the character```                        If your name contains a space, please surround the name with double quotes ("")!''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_character(self, ctx, name, user : discord.User, info, *, value):        insert_col = ''        insert_val = ''        #                        0       1        2         3            4       5        6         7       8       9        acceptable_strings = ['name', 'class', 'race', 'stat_list', 'weapon', 'armor', 'potion', 'level', 'exp', 'desc']        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                             0            1          2        3         4          5          6           7      8       9        cursor.execute(f'SELECT character_name, class_id, race_id, stat_list, weapon_id, armor_id, item_id_list, level, exp, character_desc FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user.id} AND character_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send('A character with this name does not exist for this user!')            return        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    cursor.execute(                        f'SELECT character_name FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user} AND character_name = {name}')                    res1 = cursor.fetchone()                    if res1 is None:                        insert_col = 'character_name'                        insert_val = value                    else:                        await ctx.send('This name already exists for this character! Please pick a different name!')                        return                elif info == acceptable_strings[1]:                    cursor.execute(                        f'SELECT class_name, add_sub_hp, add_sub_mp, add_sub_ep, stats_plus_min, stat_spell_save, unarmed_attack_damage, spell_array, class_ac_roll_stat, start_weapon, start_armor, start_items, class_desc FROM classes WHERE guild_id = {ctx.guild.id} AND class_name = {value}')                    res2 = cursor.fetchone()                    if res2 is not None:                        insert_col = 'class_id'                        insert_val = value                    else:                        await ctx.send('The class inserted does not exist!')                        return                elif info == acceptable_strings[2]:                    cursor.execute(                        f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {value}')                    res3 = cursor.fetchone()                    if res3 is not None:                        insert_col = 'race_id'                        insert_val = value                    else:                        await ctx.send('The race inserted does not exist!')                        return                elif info == acceptable_strings[3]:                    if value.find(',') != -1:                        x = value.split(',')                        if len(x) == 6 and can_list_be_int(x):                            insert_col = 'stat_list'                            insert_val = value                        elif len(x) != 6:                            await ctx.send(                                f'THe list is to small! The current list is {result[3]}! Please manipulate these values and paste in this format!')                            return                        elif not can_list_be_int(x):                            await ctx.send(                                f'The value does not contain integers! The current list is {result[3]}! Please manipulate these values and paste in this format!')                            return                        else:                            await ctx.send(                                f'There is an unknown error with this list! The current list is {result[3]}! Please manipulate these values and paste in this format!')                            return                    else:                        await ctx.send(                            f'The value is in an incorrect form! The current list is {result[3]}! Please manipulate these values and paste in this format!')                        return                elif info == acceptable_strings[4]:                    cursor.execute(                        f'SELECT weapon_name FROM weapons WHERE guild_id = {ctx.guild.id} AND weapon_name = {value}')                    weap = cursor.fetchone()                    if weap is not None:                        insert_col = 'weapon_id'                        insert_val = value                    else:                        await ctx.send('The weapon does not exist!')                elif info == acceptable_strings[5]:                    cursor.execute(                        f'SELECT armor_name FROM armors WHERE guild_id = {ctx.guild.id} AND armor_name = {value}')                    arm = cursor.fetchone()                    if arm is not None:                        insert_col = 'armor_id'                        insert_val = value                    else:                        await ctx.send('The armor does not exist!')                        return                elif info == acceptable_strings[6]:                    cursor.execute(                        f'SELECT potion_name FROM potions WHERE guild_id = {ctx.guild.id} AND potion_name = {value}')                    pot = cursor.fetchone()                    if pot is not None:                        insert_col = 'item_id_list'                        insert_val = value                    else:                        await ctx.send('The potion does not exist!')                elif info == acceptable_strings[7]:                    lvl_list = get_val_from_json('lvllist.json')                    x = lvl_list.split(',')                    if can_be_int(value):                        if value <= (len(x) + 1):                            sql = ('UPDATE character SET level = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')                            val = (value, ctx.guild.id, user.id, name)                            cursor.execute(sql, val)                            sql2 = ('UPDATE character SET exp = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')                            val_one = ("0", ctx.guild.id, user.id, name)                            val_else = (x[int(value) - 2], user.id, name)                            if int(value) == 1:                                cursor.execute(sql2, val_one)                            else:                                cursor.execute(sql2, val_else)                            return                        else:                            await ctx.send('The value you inserted goes beyond the max level!')                            return                    else:                        await ctx.send('The value you inserted must be an integer!')                        return                elif info == acceptable_strings[8]:                    lvl_list = get_val_from_json('lvllist.json')                    x = lvl_list.split(',')                    y = [int(i) for i in x]                    level_int = 0                    if value < 0:                        await ctx.send('The exp value must be greater than zero!')                        return                    elif value == 0:                        level_int = 1                    elif value >= y[::-1]:                        level_int = len(y)                    else:                        level_int = next(j for j, val in enumerate(y) if val > value)                        level_int += 1                    sql = ('UPDATE character SET exp = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')                    val = (value, ctx.guild.id, user.id, name)                    cursor.execute(sql, val)                    sql2 = ('UPDATE character SET level = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')                    val2 = (level_int, ctx.guild.id, user.id, name)                    cursor.execute(sql2, val2)                    db.commit()                    cursor.close()                    db.close()                    return                elif info == acceptable_strings[9]:                    insert_col = 'character_desc'                    insert_val = value                else:                    await ctx.send(f'''The value you want to change does not exist!                    ```update_character [name] [user] [info] [value]                    where name is the name of the character you want to change                    where user is a mention to the user of the character you want to change                    where info is the info you want to change                        The acceptable strings are                            name which changes the name of the character                            class which changes the character's class                            race which changes the race of the character                            stat_list which sets the stats of the character                            weapon which sets the weapon of the character                            armor which sets the armor of the character                            potion which sets the potion of the character                            level which sets the level of the character                            exp which sets the experience of the character                            desc which changes the description of the character                        where value is the value you are changing the data to                                                    If the character name has a space in it, please surround it with double quotes ("")!''')            else:                await ctx.send(f'''The value you want to change does not exist!                 ```update_character [name] [user] [info] [value]                 where name is the name of the character you want to change                 where user is a mention to the user of the character you want to change                 where info is the info you want to change                    The acceptable strings are                        name which changes the name of the character                        class which changes the character's class                        race which changes the race of the character                        stat_list which sets the stats of the character                        weapon which sets the weapon of the character                        armor which sets the armor of the character                        potion which sets the potion of the character                        level which sets the level of the character                        exp which sets the experience of the character                        desc which changes the description of the character                    where value is the value you are changing the data to                                        If the character name has a space in it, please surround it with double quotes ("")!''')    @update_character.error    async def update_character_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''This error is missing argumenmts!```update_character [name] [user] [info] [value]                where name is the name of the character you want to change                where user is a mention to the user of the character you want to change                where info is the info you want to change                    The acceptable strings are                        name which changes the name of the character                        class which changes the character's class                        race which changes the race of the character                        stat_list which sets the stats of the character                        weapon which sets the weapon of the character                        armor which sets the armor of the character                        potion which sets the potion of the character                        level which sets the level of the character                        exp which sets the experience of the character                        desc which changes the description of the character                    where value is the value you are changing the data to                                            If the character name has a space in it, please surround it with double quotes ("")!''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_character(self, ctx, name, user: discord.User):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                             0            1          2        3         4          5          6           7      8       9        cursor.execute(f'SELECT character_name, class_id, race_id, stat_list, weapon_id, armor_id, item_id_list, level, exp, character_desc FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {user.id} AND character_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send('This character does not exist for this user!')        else:            sql = ('DELETE FROM characters WHERE guild_id = ? AND user_id = ? AND character_name = ?')            val = (ctx.guild.id, user.id, name)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @delete_character.error    async def delete_character_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''This command is missing a command!            ```delete_character [name] [user]            where name is the name of the character            where user is the mention of the user of the character```                        If your name contains a space, please surround the name with double quotes ("")!''')    @commands.command()    async def set_weapon(self, ctx, name, weapon):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT weapon_name FROM player_weapon WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND weapon_name = {weapon}')        res1 = cursor.fetchone()        cursor.execute(f'SELECT character_name FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND character_name = {name}')        res2 = cursor.fetchone()        if res1 is None or res2 is None:            await ctx.send(f'You do not own weapon {weapon} or the character {name} is not yours/does not exist! Check to see if you put double quotes ("") around any values with a space')            return        else:            sql = ('UPDATE characters SET weapon_id = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')            val = (weapon, ctx.guild.id, ctx.message.author.id, name)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @set_weapon.error    async def set_weapon_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```set_weapon [name] [weapon]            where name is the name of your character you are adding to the weapon            where weapon is the name of the weapon from your inventory```                        If your character or weapon name contains a space, please use double quotes ("") around the value!''')    @commands.command()    async def set_armor(self, ctx, name, armor):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT armor_name FROM player_armor WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND armor_name = {armor}')        res1 = cursor.fetchone()        cursor.execute(f'SELECT character_name FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND character_name = {name}')        res2 = cursor.fetchone()        if res1 is None or res2 is None:            await ctx.send(f'You do not own armor {armor} or the character {name} is not yours/does not exist! Check to see if you put double quotes ("") around any values with a space')            return        else:            sql = ('UPDATE characters SET armor_id = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')            val = (armor, ctx.guild.id, ctx.message.author.id, name)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @set_armor.error    async def set_armor_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```set_armor [name] [armor]            where name is the name of your character you are adding to the weapon            where armor is the name of the armor from your inventory```                        If your character or armor name contains a space, please use double quotes ("") around the value!''')    @commands.command()    async def set_potion(self, ctx, name, potion):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT potion_name FROM player_potion WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND potion_name = {potion}')        res1 = cursor.fetchone()        cursor.execute(            f'SELECT character_name FROM characters WHERE guild_id = {ctx.guild.id} AND user_id = {ctx.message.author.id} AND character_name = {name}')        res2 = cursor.fetchone()        if res1 is None or res2 is None:            await ctx.send(                f'You do not own potion {potion} or the character {name} is not yours/does not exist! Check to see if you put double quotes ("") around any values with a space')            return        else:            sql = ('UPDATE characters SET item_id_list = ? WHERE guild_id = ? AND user_id = ? AND character_name = ?')            val = (potion, ctx.guild.id, ctx.message.author.id, name)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @set_armor.error    async def set_potion_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```set_potion [name] [potion]            where name is the name of your character you are adding to the weapon            where potion is the name of the potion from your inventory```            If your character or potion name contains a space, please use double quotes ("") around the value!''')def setup(client):    client.add_cog(Characters(client))