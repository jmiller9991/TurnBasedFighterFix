import discordimport randomimport jsonfrom discord.ext import commands, tasksfrom itertools import cycleimport sqlite3import asyncioimport math#########################################################################################################################   Character Class                                                                                                    ##                                                                                                                      ##   This class is to contain all commands for making characters and its associated data.                               ##   This class will need to create/read/update/delete (CRUD) for conditions, abilities, spells, levels, races,         ##   classes and characters. I will also need creators for these things which will create this data step by step.       #########################################################################################################################async def can_be_int(val):    try:        int(val)        return True    except ValueError:        return Falseasync def can_list_be_int(string_list):    correct = True    for i in string_list:        if can_be_int(i):            correct = True        else:            return False    return correctasync def get_val_from_json(ctx, file):    with open(file, 'r') as f:        hp_name = json.load(f)    return hp_name[str(ctx.guild.id)]class Characters(commands.Cog):    ####################################################################################################################    #   Necessary Code                                                                                                 #    ####################################################################################################################    def __init__(self, client):        self.client = client    ####################################################################################################################    #   Conditions                                                                                                     #    ####################################################################################################################    #database command for create    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_cond_by_db(self, ctx, name, type, turns, damage, cond_roll, gain_loss, effect_stat, lose_turn, *, desc):        successful = True        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {name}')        result = cursor.fetchone()        if result is not None:            exists == True        error_loc = ''        if not type == "PHYSICAL" or not type == "SPECIAL":            successful = False            error_loc = 'move type'        if damage.find('d') == -1:            successful = False            error_loc = 'damage dice'        elif damage.find('d') != -1:            x = damage.split('d')            if not can_be_int(x[0]) or not can_be_int(x[1]):                successful = False                error_loc = 'damage dice'            elif int(x[0]) < 0 or int(x[1]) < 0 :                successful = False                error_loc = 'damage dice'        elif  damage != 'NONE':            successful = False            error_loc = 'damage dice'        if cond_roll != 'NONE' or cond_roll != 'stat1' or cond_roll != 'stat2' or cond_roll != 'stat3' or cond_roll != 'stat4' or cond_roll != 'stat5' or cond_roll != 'stat6':            successful = False            error_loc = 'stat to roll to break free'        if  gain_loss != 'GAIN' or not gain_loss == 'LOSS':            successful = False            error_loc = 'gain or loss'        if effect_stat != 'HP' or effect_stat != 'MP' or effect_stat != 'EP' or effect_stat != 'stat1' or effect_stat != 'stat2' or effect_stat != 'stat3' or effect_stat != 'stat4' or effect_stat != 'stat5' or effect_stat != 'stat6':            successful = False            error_loc = 'stat effected'        if lose_turn.find('d') == -1:            successful = False            error_loc = 'lose a turn'        elif lose_turn.find('d') != -1:            x = lose_turn.split('d')            if not can_be_int(x[0]) or can_be_int(x[1]):                successful = False                error_loc = 'lose a turn'            elif int(x[0]) < 0 or int(x[1]) < 0:                successful = False                error_loc = 'lose a turn'        elif lose_turn != 'NO':            successful = False            error_loc = 'lose a turn'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                                 1            2              3                 4                5                   6                      7                    8                 9                   10            sql = ('INSERT INTO effectcond(guild_id, condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc) VALUES(?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, type, turns, damage, cond_roll, gain_loss, effect_stat, lose_turn, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()            await ctx.send(f'Condition {name} was successfully created')        else:            if successful == False:                await ctx.send(f'''Condition has failed in {error_loc} section.```create_cond_by_db [name] [type] [turns] [damage] [stat to break free] [gain or loss] [stat effected] [lose turn] [description]                ```where name is the name of the condition                where type is if the condition is physical or special                where turns is the number of turns effected as a dice                where damage is the damage dice                where stat to break free is the stat used to break free from the condition or NONE if not                where gain or loss if the condition give to the stat effected or removes from the stat effected                where stat effected is the stat effected by the condition                where lose turn if the condition causes the player to lose a turn                where description is the description of the condition                                for all but description please use double quotation marks ("") around the section if spaces are present''')            elif exists == True:                await ctx.send('A condition with that name does not exists! Please choose a different name!')    @create_cond_by_db.error    async def create_cond_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''An argument is missing from the command or incorrectly formatted!            ```create_cond_by_db [name] [type] [turns] [damage] [stat to break free] [gain or loss] [stat effected] [lose turn] [description]```            where name is the name of the condition            where type is if the condition is physical or special            where turns is the number of turns effected as a dice            where damage is the damage dice            where stat to break free is the stat used to break free from the condition or NONE if not            where gain or loss if the condition give to the stat effected or removes from the stat effected            where stat effected is the stat effected by the condition            where lose turn if the condition causes the player to lose a turn            where description is the description of the condition                        for all but description please use double quotation marks ("") around the section if spaces are present''')        else:            await ctx.send('An error has occurred!')    #show a condition    @commands.command()    async def show_condition(self, ctx, cond_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                              0            1              2                 3                       4                   5                      6                    7             8        cursor.execute(f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            await ctx.send(f'''{result[0]}            ```Type: {result[1]}            Turns Effected: {result[2]}            Damage: {result[3]}            Stat to break free: {result[4]}            Causes: {result[5]} in {result[6]}            Lose a turn?: {result[7]}                        Description:\n{result[8]}''')    @show_condition.error    async def show_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''An argument is missing from the command or incorrectly formatted!            ```show_condition [cond_name]```            where cond_name is the name of the condition                        for all but description please use double quotation marks ("") around the section if spaces are present''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_condition(self, ctx, cond_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                              0            1              2                 3                       4                   5                      6                    7             8        cursor.execute(f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        last_val = cursor.fetchone()        accepted_strings = ['name', 'type', 'turns', 'damage', 'stat_free', 'gain_loss', 'stat_effected', 'lose_turn', 'desc']        if last_val is None:            await ctx.send(f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            if info in accepted_strings:                if info == accepted_strings[0]:                    sql = ('UPDATE effectcond SET condition_name = ? WHERE guild_id = ? AND condition_name = ?')                    val = (value, ctx.guild.id, cond_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == accepted_strings[1]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        sql = ('UPDATE effectcond SET condition_type = ? WHERE guild_id = ? AND condition_name = ?')                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value was not acceptable, the value is staying as it was!')                elif info == accepted_strings[2]:                    if value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                sql = ('UPDATE effectcond SET condition_turns = ? WHERE guild_id = ? AND condition_name = ?')                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send('The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send('The dice format must be XdY where X is number of dice and Y is the max value of the dice!')                elif info == accepted_strings[3]:                    if value == 'None':                        sql = ('UPDATE effectcond SET condition_damage = ? WHERE guild_id = ? AND condition_name = ?')                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                sql = ('UPDATE effectcond SET condition_damage = ? WHERE guild_id = ? AND condition_name = ?')                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send(                                'The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send(                            'The dice format must be XdY where X is number of dice and Y is the max value of the dice or the value must be NONE!')                elif info == accepted_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    result = cursor.fetchone()                    if value == result[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat1", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat2", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat3", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat4", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat5", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat6", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == 'NONE':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_effect_roll = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("None", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is not acceptable. The value will stay the same!')                elif info == accepted_strings[5]:                    if value == 'GAIN' or value == 'LOSS':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = ("UPDATE effectcond SET condition_gain_loss = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value was not GAIN or LOSS and will stay the same!')                elif info == accepted_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    result = cursor.fetchone()                    if value == result[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat1", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat2", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat3", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat4", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat5", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == result[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("stat6", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == 'NONE':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET condition_effect_stat = ? WHERE guild_id = ? AND condition_name = ?")                        val = ("None", ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is not acceptable. The value will stay the same!')                elif info == accepted_strings[7]:                    if value == 'NO':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE effectcond SET cause_lose_turn = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, cond_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                db = sqlite3.connect('main.sqlite')                                cursor = db.cursor()                                sql = (                                    "UPDATE effectcond SET cause_lose_turn = ? WHERE guild_id = ? AND condition_name = ?")                                val = (value, ctx.guild.id, cond_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The dices values must be greater than 0! The value will not change!')                        else:                            await ctx.send(                                    'The values of the number of dice and/or the max dice value must be integers.')                    else:                        await ctx.send(                                'The dice format must be XdY where X is number of dice and Y is the max value of the dice or the value must be NO!')                elif info == accepted_strings[8]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE effectcond SET condition_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, cond_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The command has an incorrect argument!                    ```update_condition [cond_name] [info] [value]                    where cond_name is the name of the condition                    where info is one of the acceptable strings name to change the name, type to change the type of the condition, turns to change the number of turns, damage to change the damage dice, stat_free to change the stat added to break free, gain_loss to change if the effect add or removes from the effected stat, stat_effected to show the effected stat, lose_turn to change if they lose a turn or the dice equal to the number of turns, desc to change the description                    where value is the value of the data```''')    @update_condition.error    async def update_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!                                ```update_condition [cond_name] [info] [value]                                where cond_name is the name of the condition                                where info is one of the acceptable strings name to change the name, type to change the type of the condition, turns to change the number of turns, damage to change the damage dice, stat_free to change the stat added to break free, gain_loss to change if the effect add or removes from the effected stat, stat_effected to show the effected stat, lose_turn to change if they lose a turn or the dice equal to the number of turns, desc to change the description                                where value is the value of the data```''')        else:            await ctx.send('An odd error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_condition(self, ctx, cond_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_name}')        last_val = cursor.fetchone()        if last_val is None:            await ctx.send(                f'The condition {cond_name} is not valid! There could have been two problems, either you did not use double quotations ("") around the condition name or it does not exist!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM effectcond WHERE guild_id = ? AND condition_name = ?')            val = (ctx.guild.id, cond_name)            db.commit()            cursor.close()            db.close()            await ctx.send(f'Deleted {cond_name}')    @delete_condition.error    async def delete_cond_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!            ```delete_condition [cond_name]            where cond_name is the name of the condition```''')        else:            await ctx.send('An error has occurred!')    ####################################################################################################################    #   Abilities                                                                                                      #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_ability_by_db(self, ctx, name, type, range, cond, *, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        successful = True        error_loc = ''        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'Ability Type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'Ability Range'        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')        last_val = cursor.fetchone()        if last_val is None:            successful = False            error_loc = 'Assigning Conditions'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('INSERT INTO abilities(guild_id, ability_name, ability_type, buff_range, buff_condition, ability_desc) VALUES(?,?,?,?,?,?)')            val = (ctx.guild.id, name, type, range, cond, desc)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''An error occurred in {error_loc}!                ```create_ability_by_db [name] [type] [range] [cond] [desc]                where name is the name of the ability                where type is the type of the ability                where range is if it effects the player character or the other player's character                where cond is the condition associated with the ability                where desc is equal to the description of the class                                If you are putting a space in anything but the description, please surround it in double quotes ("").''')            elif exists:                await ctx.send('An ability with this name already exists! Please try again!')    @create_ability_by_db.error    async def create_ability_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''An command is missing an argument!            ```create_ability_by_db [name] [type] [range] [cond] [desc]            where name is the name of the ability            where type is the type of the ability            where range is if it effects the player character or the other player's character            where cond is the condition associated with the ability            where desc is equal to the description of the class                        If you are putting a space in anything but the description, please surround it in double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_ability(self, ctx, ability_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {ability_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {ability_name} does not exist! If the name has a space, please surround the data with double quotes ("").')        else:            await ctx.send(f'''{result[0]}            ```Type: {result[1]}            Effects: {result[2]}            Condition Given:{result[3]}            Description:\n{result[4]}''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_ability(self, ctx, abil_name, info, *, value):        acceptable_strings = ['name', 'type', 'range', 'cond', 'desc']        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {abil_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {abil_name} does not exist! If the name has a space, please surround the data with double quotes ("").')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE abilities SET ability_type = ? WHERE guild_id = ? AND ability_name = ?")                    val = (value, ctx.guild.id, abil_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    if value == "PHYSICAL" or value == "SPECIAL":                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET ability_type = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send('The value is incorrect, the value will return to the previous value!')                elif info == acceptable_strings[2]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET buff_range = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[3]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    last_val = cursor.fetchone()                    if last_val is None:                        await ctx.send('The value entered is not a condition. The value is going to stay the same!')                    else:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE abilities SET buff_condition = ? WHERE guild_id = ? AND ability_name = ?")                        val = (value, ctx.guild.id, abil_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE abilities SET ability_desc = ? WHERE guild_id = ? AND ability_name = ?")                    val = (value, ctx.guild.id, abil_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send(f'''The value you inputted was not acceptable!                    ```update_ability [abil_name] [info] [value]                    where abil_name is the ability name                    where info is the thing to change                    where value is the new value```''')            else:                await ctx.send(f'''The value you inputted was not acceptable!                ```update_ability [abil_name] [info] [value]                where abil_name is the ability name                where info is the thing to change                where value is the new value```''')    @update_ability.error    async def update_ability_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```update_ability [abil_name] [info] [value]            where abil_name is the ability name            where info is the thing to change            where value is the new value```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_ability(self, ctx, abil_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {abil_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The ability {abil_name} does not exist!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql  = ('DELETE FROM abilities WHERE ability_name = ? AND guild_id = ?')            val = (abil_name, ctx.guild.id)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    @delete_ability.error    async def delete_ability_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing arguments!            ```delete_ability [abil_name]            where abil_name is the name of the ability```                        If the name has a space, pleasse use double quotes ("") around the name.''')    ####################################################################################################################    #   Spells                                                                                                         #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_spell_attack(self, ctx, name, stat_used, type, range, damage, save, *, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        successful = True        error_loc = ''        if stat_used not in stats:            successful = False            error_loc = 'getting stat used to cast'        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'setting type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'setting range'        if damage.find('d') == -1:            successful = False            error_loc = 'setting damage'        elif damage.find('d') != -1:            x = damage.split('d')            if can_be_int(x[0]) and can_be_int(x[1]):                if int(x[0]) < 0 or int(x[1]):                    successful = False                    error_loc = 'setting damage'            else:                successful = False                error_loc = 'setting damage'        elif damage != 'NONE':            successful = False            error_loc = 'setting damage'        if save not in stats or save != 'NONE':            successful = False            error_loc = 'getting stat used to cast'        if successful and exists == False:            if stat_used == stats[0]:                stat_to_cast = 'stat1'            elif stat_used == stats[1]:                stat_to_cast = 'stat2'            elif stat_used == stats[2]:                stat_to_cast = 'stat3'            elif stat_used == stats[3]:                stat_to_cast = 'stat4'            elif stat_used == stats[4]:                stat_to_cast = 'stat5'            elif stat_used == stats[5]:                stat_to_cast = 'stat6'            if save == stats[0]:                stat_to_save = 'stat1'            elif save == stats[1]:                stat_to_save = 'stat2'            elif save == stats[2]:                stat_to_save = 'stat3'            elif save == stats[3]:                stat_to_save = 'stat4'            elif save == stats[4]:                stat_to_save = 'stat5'            elif save == stats[5]:                stat_to_save = 'stat6'            elif save == 'NONE':                stat_to_save = 'NONE'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                              1           2        3            4            5            6             7            8              9                  10            sql = ('INSERT INTO spells(guild_id, spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc) VALUES(?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, 'ATTACK', stat_to_cast, type, range, damage, stat_to_save, 'NONE', desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''The command failed at {error_loc}!                 ```create_spell_attack [name] [stat_used] [type] [range] [damage] [save] [desc]                where name is the name of the spell                where stat_used is the name of the stat added to cast                where type is the type of spell                where range is if it effects the user or the enemy                where damage is the damage of the spell                where save is the stat used to save against the spell                where desc is the description of the spell```                                If one of the values contains a space outside of the description, then surround the value by double quotes ("").''')            elif exists:                await ctx.send('A spell with that name exists! Please choose a different name!')    @create_spell_attack.error    async def create_spell_attack_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing arguments!            ```create_spell_attack [name] [stat_used] [type] [range] [damage] [save] [desc]            where name is the name of the spell            where stat_used is the name of the stat added to cast            where type is the type of spell            where range is if it effects the user or the enemy            where damage is the damage of the spell            where save is the stat used to save against the spell            where desc is the description of the spell```                        If one of the values contains a space outside of the description, then surround the value by double quotes ("").''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_spell_buff(self, ctx, name, stat_uses, type, range, save, buff_debuff_cond, *s, desc):        exists = False        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        successful = True        error_loc = ''        if stat_uses not in stats:            successful = False            error_loc = 'getting stat used to cast'        if type != 'PHYSICAL' or type != 'SPECIAL':            successful = False            error_loc = 'setting type'        if range != 'SELF' or range != 'ENEMY':            successful = False            error_loc = 'setting range'        if save not in stats or save != 'NONE':            successful = False            error_loc = 'getting stat used to cast'        cursor.execute(f'SELECT condition_name FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {buff_debuff_cond}')        cond = cursor.fetchone()        if cond is None:            successful = False            error_loc = 'setting condition'        if successful and exists == False:            if stat_uses == stats[0]:                stat_to_cast = 'stat1'            elif stat_uses == stats[1]:                stat_to_cast = 'stat2'            elif stat_uses == stats[2]:                stat_to_cast = 'stat3'            elif stat_uses == stats[3]:                stat_to_cast = 'stat4'            elif stat_uses == stats[4]:                stat_to_cast = 'stat5'            elif stat_uses == stats[5]:                stat_to_cast = 'stat6'            if save == stats[0]:                stat_to_save = 'stat1'            elif save == stats[1]:                stat_to_save = 'stat2'            elif save == stats[2]:                stat_to_save = 'stat3'            elif save == stats[3]:                stat_to_save = 'stat4'            elif save == stats[4]:                stat_to_save = 'stat5'            elif save == stats[5]:                stat_to_save = 'stat6'            elif save == 'NONE':                stat_to_save = 'NONE'            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('INSERT INTO spells(guild_id, spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc) VALUES(?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, 'BUFF', stat_to_cast, type, range, 'NONE', stat_to_save, buff_debuff_cond, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send('''The command has an error in it!                ```create_spell_buff [name] [stat_used] [type] [range] [save] [buff_debuff_cond] [desc]                where name is the name of the spell                where stat_used is the stat used to cast the spell                where type is the type of the move                where range is if the spell effects the user or the enemy                where save is the stat added to save against the stat                where buff_debuff_cond is the condition for the buff or debuff                where desc is the description of the spell```                                If there is a space in any of those values except for description, surround the value with double quotes ("").''')            elif exists:                await ctx.send('A spell with that name already exists. Please pick a different name!')    @create_spell_buff.error    async def create_spell_buff_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing parameters!                           ```create_spell_buff [name] [stat_used] [type] [range] [save] [buff_debuff_cond] [desc]                           where name is the name of the spell                           where stat_used is the stat used to cast the spell                           where type is the type of the move                           where range is if the spell effects the user or the enemy                           where save is the stat added to save against the stat                           where buff_debuff_cond is the condition for the buff or debuff                           where desc is the description of the spell```                                                      If there is a space in any of those values except for description, surround the value with double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_spell(self, ctx, *, spell_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'''The spell {spell_name} does not exist!            ```show_spell [spell_name]            where spell_name is the name of the spell```''')        else:            cursor.execute(                f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')            stats = cursor.fetchone()            if result[2] == stats[0]:                casting = 'stat1'            elif result[2] == stats[1]:                casting = 'stat2'            elif result[2] == stats[2]:                casting = 'stat3'            elif result[2] == stats[3]:                casting = 'stat4'            elif result[2] == stats[4]:                casting = 'stat5'            elif result[2] == stats[5]:                casting = 'stat6'            if result[6] == stats[0]:                stat_to_save = 'stat1'            elif result[6] == stats[1]:                stat_to_save = 'stat2'            elif result[6] == stats[2]:                stat_to_save = 'stat3'            elif result[6] == stats[3]:                stat_to_save = 'stat4'            elif result[6] == stats[4]:                stat_to_save = 'stat5'            elif result[6] == stats[5]:                stat_to_save = 'stat6'            elif result[6] == 'NONE':                stat_to_save = 'NONE'            if result[1] == 'ATTACK':                await ctx.send(f'''{result[0]} : {result[1]}                ```Spell adds {casting} to the spell roll                Type: {result[3]}                Range: {result[4]}                Damage: {result[5]}                Save: {stat_to_save}                                Description:\n{result[8]}''')            elif result[1] == 'BUFF':                await ctx.send(f'''{result[0]} : {result[1]}                ```Spell adds {casting} to the spell roll                Type: {result[3]}                Range: {result[4]}                Condition: {result[7]}                Save: {stat_to_save}                                Description:\n{result[8]}''')    @show_condition.error    async def show_condition_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing arguments!            ```show_spell [spell_name]            where spell_name is the name of the spell```''')    @commands.command()    @commands.has_guild_permissions(administrator = True)    async def update_attack_spell(self, ctx, spell_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        acceptable_strings = ['name', 'stat_used', 'type', 'range', 'damage', 'save', 'desc']        if result is None:            await ctx.send(f'''This spell does not exist!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, damage, save, and desc```''')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_name = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[2]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_type = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not PHYSICAL or SPECIAL. Keeping it the same!')                elif info == acceptable_strings[3]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_range = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not SELF or ENEMY. Keeping it the same!')                elif info == acceptable_strings[4]:                    if value.find('d') != -1:                        x = value.split('d')                        if can_be_int(x[0]) and can_be_int(x[1]):                            if int(x[0]) > 0 and int(x[1]) > 0:                                db = sqlite3.connect('main.sqlite')                                cursor = db.cursor()                                sql = (                                    "UPDATE spells SET spell_damage = ? WHERE guild_id = ? AND condition_name = ?")                                val = (value, ctx.guild.id, spell_name)                                cursor.execute(sql, val)                                db.commit()                                cursor.close()                                db.close()                            else:                                await ctx.send('The value XdY contains a value not greater than one. X is the number of dice and Y is the max dice value! The value will remain the same as before!')                        else:                            await ctx.send('The value XdY contains a value that is not an int. X is the number of dice and Y is the max dice value! The value will remain the same as before!')                    else:                        await ctx.send('The must be in  XdY form where X is the number of dice and Y is the max dice value! The value will remain the same as before!')                elif info == acceptable_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = ('stat6', ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The value you want to change is not acceptable!                    ```update_attack_spell [spell_name] [info] [value]                    where spell_name is the name of the spell you are looking for                    where info is the info you want to changes                    where value is the value to set the info to                    the values that info can be are name, stat_used, type, range, damage, save, and desc```''')            else:                await ctx.send('''The value you want to change is not acceptable!                ```update_attack_spell [spell_name] [info] [value]                where spell_name is the name of the spell you are looking for                where info is the info you want to changes                where value is the value to set the info to                the values that info can be are name, stat_used, type, range, damage, save, and desc```''')    @update_attack_spell.error    async def update_attack_spell(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an appropriate value!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, damage, save, and desc```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_buff_spell(self, ctx, spell_name, info, *, value):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        acceptable_strings = ['name', 'stat_used', 'type', 'range', 'condition', 'save', 'desc']        if result is None:            await ctx.send(f'''This spell does not exist!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, condition, save, and desc```''')        else:            if info in acceptable_strings:                if info == acceptable_strings[0]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_name = ? WHERE guild_id = ? AND condition_name = ?")                    val = (value, ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                elif info == acceptable_strings[1]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_uses = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[2]:                    if value == 'PHYSICAL' or value == 'SPECIAL':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_type = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not PHYSICAL or SPECIAL. Keeping it the same!')                elif info == acceptable_strings[3]:                    if value == 'SELF' or value == 'ENEMY':                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_range = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value is not SELF or ENEMY. Keeping it the same!')                elif info == acceptable_strings[4]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    cond = cursor.fetchone()                    if cond is None:                        await ctx.send('The condition does not exist! Keeping the value the same!')                    else:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET buff_debuff_condition = ? WHERE guild_id = ? AND condition_name = ?")                        val = (value, ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                elif info == acceptable_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')                    stats = cursor.fetchone()                    if value == stats[0]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat1', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[1]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat2', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[2]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat3', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[3]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat4', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[4]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat5', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    elif value == stats[5]:                        db = sqlite3.connect('main.sqlite')                        cursor = db.cursor()                        sql = (                            "UPDATE spells SET spell_save = ? WHERE guild_id = ? AND condition_name = ?")                        val = ('stat6', ctx.guild.id, spell_name)                        cursor.execute(sql, val)                        db.commit()                        cursor.close()                        db.close()                    else:                        await ctx.send(f'The value does not match the stats. Keeping it the same!')                elif info == acceptable_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    sql = (                        "UPDATE spells SET spell_desc = ? WHERE guild_id = ? AND condition_name = ?")                    val = ('stat6', ctx.guild.id, spell_name)                    cursor.execute(sql, val)                    db.commit()                    cursor.close()                    db.close()                else:                    await ctx.send('''The value you want to change is not acceptable!                    ```update_attack_spell [spell_name] [info] [value]                    where spell_name is the name of the spell you are looking for                    where info is the info you want to changes                    where value is the value to set the info to                    the values that info can be are name, stat_used, type, range, condition, save, and desc```''')            else:                await ctx.send('''The value you want to change is not acceptable!                ```update_attack_spell [spell_name] [info] [value]                where spell_name is the name of the spell you are looking for                where info is the info you want to changes                where value is the value to set the info to                the values that info can be are name, stat_used, type, range, condition, save, and desc```''')    @update_buff_spell.error    async def update_attack_spell(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an appropriate value!            ```update_attack_spell [spell_name] [info] [value]            where spell_name is the name of the spell you are looking for            where info is the info you want to changes            where value is the value to set the info to            the values that info can be are name, stat_used, type, range, condition, save, and desc```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_spell(self, ctx, spell_name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(            f'SELECT spell_name, attack_buff, spell_uses, spell_type, spell_range, spell_damage, spell_save, buff_debuff_condition, spell_desc FROM spells WHERE guild_id = {ctx.guild.id} AND spell_name = {spell_name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'''The spell {spell_name} does not exist!            ```delete_spell [spell_name]            where spell_name is the name of the spell```''')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM spells WHERE spell_name = ? AND guild_id = ?')            val = (spell_name, ctx.guild.id)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()    ####################################################################################################################    #   Races                                                                                                          #    ####################################################################################################################    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def create_race_by_db(self, ctx, name, set_hp, set_mp, set_ep, stat_list_plus_min, cond_immune_list, cond_resist_list, cond_vulnerable_list, ability_list, *, desc):        exists = False        successful = True        error_loc = ''        cond_immune_str = ''        cond_immune_failed = ''        cond_resist_str = ''        cond_resist_failed = ''        cond_vulnerable_str = ''        cond_vulnerable_failed = ''        ability_str = ''        ability_failed = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is not None:            exists = True        if not can_be_int(set_hp):            successful = False            error_loc = 'setting hp'        elif can_be_int(set_hp):            if int(set_hp):                successful = False                error_loc = 'setting hp'        if not can_be_int(set_mp):            successful = False            error_loc = 'setting mp'        elif can_be_int(set_mp):            if int(set_mp):                successful = False                error_loc = 'setting mp'        if not can_be_int(set_ep):            successful = False            error_loc = 'setting ep'        elif can_be_int(set_ep):            if int(set_mp):                successful = False                error_loc = 'setting ep'        if stat_list_plus_min.find(',') == -1:            successful = False            error_loc = 'setting the add and subtract values of stats'        elif stat_list_plus_min.find(',') != -1:            x = stat_list_plus_min.split(',')            if len(x) != 6:                successful = False                error_loc = 'setting the add and subtract values of stats'            elif can_list_be_int(x):                successful = False                error_loc = 'setting the add and subtract values of stats'        if cond_immune_list.find(',') == -1:            if cond_immune_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_immune_list}')                res = cursor.fetchone()                if res is None:                    successful = False                    error_loc = 'setting the conditions you are immune to'                    cond_immune_str == 'NONE'        elif cond_immune_list.find(',') != -1:            x = cond_immune_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_immune_str += f'{cond},'                else:                    cond_immune_failed += f'{cond},'            cond_immune_str.rstrip(',')            cond_immune_failed.rstrip(',')            if cond_immune_str == '':                cond_immune_str == 'NONE'            await ctx.send(f'{cond_immune_failed} failed to add')        else:            successful = False            error_loc = 'setting the conditions you are immune to'            cond_immune_str == 'NONE'        if cond_resist_list.find(',') == -1:            if cond_resist_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_resist_list}')                res = cursor.fetchone()                if res is None:                    successful = False                    error_loc = 'setting the conditions you are resistant to'                    cond_resist_str == 'NONE'        elif cond_resist_list.find(',') != -1:            x = cond_resist_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_resist_str += f'{cond},'                else:                    cond_resist_failed += f'{cond},'            cond_resist_str.rstrip(',')            cond_resist_failed.rstrip(',')            if cond_resist_str == '':                cond_resist_str == 'NONE'            await ctx.send(f'{cond_resist_failed} failed to add')        else:            successful = False            error_loc = 'setting the conditions you are resistant to'            cond_resist_str == 'NONE'        if cond_vulnerable_list.find(',') == -1:            if cond_vulnerable_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond_vulnerable_list}')                res = cursor.fetchone()                if res is None:                    successful = False                    error_loc = 'setting the conditions you are vulnerable to'                    cond_vulnerable_str == 'NONE'        elif cond_vulnerable_list.find(',') != -1:            x = cond_vulnerable_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_vulnerable_str += f'{cond},'                else:                    cond_vulnerable_failed += f'{cond},'            cond_vulnerable_str.rstrip(',')            cond_vulnerable_failed.rstrip(',')            if cond_vulnerable_str == '':                cond_vulnerable_str == 'NONE'            await ctx.send(f'{cond_vulnerable_failed} failed to add')        else:            successful = False            error_loc = 'setting the conditions you are vulnerable to'            cond_vulnerable_str == 'NONE'        if ability_list.find(',') == -1:            if ability_list != 'NONE':                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {ability_list}')                res = cursor.fetchone()                if res is not None:                    ability_str = ability_list                else:                    ability_str = 'NONE'                    successful = False                    error_loc = 'setting the conditions you are vulnerable to'        elif ability_list.find(',') != -1:            x = ability_list.split(',')            for cond in x:                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                cursor.execute(                    f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {cond}')                res = cursor.fetchone()                if res is not None:                    cond_vulnerable_str += f'{cond},'                else:                    cond_vulnerable_failed += f'{cond},'            ability_str.rstrip(',')            ability_failed.rstrip(',')            if cond_vulnerable_str == '':                ability_str == 'NONE'            await ctx.send(f'{ability_failed} failed to add')        else:            successful = False            error_loc = 'setting the conditions you are vulnerable to'            ability_str = 'NONE'        if successful and exists == False:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            #                               1     2            3      4        5          6            7                    8                  9                     10               11            sql = ('INSERT INTO spells(guild_id, race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description) VALUES(?,?,?,?,?,?,?,?,?,?,?)')            val = (ctx.guild.id, name, set_hp, set_mp, set_ep, stat_list_plus_min, cond_immune_str, cond_resist_str, cond_vulnerable_str, ability_str, desc)            cursor.execute(sql, val)            db.commit()            cursor.close()            db.close()        else:            if successful == False:                await ctx.send(f'''The creator failed at {error_loc}.                ```create_race_by_db [name] [set_hp] [set_mp] [set_ep] [stat_list_plus_min] [cond_immune_list] [cond_resist_list] [cond_vulnerable_list] [ability_list] [desc]                where name is the name of the race                where set_hp is the value to set the hp to                where set_mp is the value to set the mp to                where set_ep is the value to set the ep to                where stat_list_plus_min is the values of each stat separated by commas                where cond_immune_list is the value of all immunities separated by commas                where cond_resist_list is the value of all resistances separated by commas                where cond_vulnerable_list is the value of all vulnerabilities separated by commas                where ability_list is the value of all abilities separated by commas```                                If a value has a space in it, please surround it with double quotes ("").''')            elif exists:                await ctx.send('The race already has that name! Please select a different name!')    @create_race_by_db.error    async def create_race_by_db_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''The command is missing an argument!            ```create_race_by_db [name] [set_hp] [set_mp] [set_ep] [stat_list_plus_min] [cond_immune_list] [cond_resist_list] [cond_vulnerable_list] [ability_list] [desc]                where name is the name of the race                where set_hp is the value to set the hp to                where set_mp is the value to set the mp to                where set_ep is the value to set the ep to                where stat_list_plus_min is the values of each stat separated by commas                where cond_immune_list is the value of all immunities separated by commas                where cond_resist_list is the value of all resistances separated by commas                where cond_vulnerable_list is the value of all vulnerabilities separated by commas                where ability_list is the value of all abilities separated by commas```                                If a value has a space in it, please surround it with double quotes ("").''')        else:            await ctx.send('An error has occurred!')    @commands.command()    async def show_race(self, ctx, *, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        hp = get_val_from_json(ctx, 'hp.json')        mp = get_val_from_json(ctx, 'mp.json')        ep = get_val_from_json(ctx, 'ep.json')        cursor.execute(            f'SELECT stat1, stat2, stat3, stat4, stat5, stat6 FROM stats WHERE guild_id = {ctx.guild.id}')        stats = cursor.fetchone()        if result[4].find(',') != -1:            x = result[4].split(',')        y = result[5].replace(',', ' ')        z = result[6].replace(',', ' ')        j = result[7].replace(',', ' ')        k = result[8].replace(',', ' ')        if result is None:            await ctx.send(f'{name} is not a race!')        else:            await ctx.send(f'''{result[0]}            ```{hp}: {result[1]}   {mp}: {result[2]}   {ep}: {result[3]}            {stats[0]}: {x[0]}   {stats[1]}: {x[1]}   {stats[2]}: {x[2]}   {stats[3]}: {x[3]}   {stats[4]}: {x[4]}   {stats[5]}: {x[5]}            Conditions Immune:\n{y}            Conditions Resistant:\n{z}            Conditions Vulnerable:\n{j}            Abilities:\n{k}                        Description:\n{result[9]}''')    @show_condition.error    async def show_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send('''The command is missing an argument!            ```show_race [name]            where name is the name of the race```''')        else:            await ctx.send('An error has occurred!')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def update_race(self, ctx, name, info, *, value):        #                      0        1         2         3              4                5                  6               7                 8                     9                 10                          11          12             13        accepted_strings = ['name', 'set_hp', 'set_mp', 'set_ep', 'change_stat_list', 'add_immunity', 'remove_immunity', 'add_resistance', 'remove_resistance', 'add_vulnerability', 'remove_vulnerability', 'add_ability', 'remove_ability', 'desc']        insert_col = ''        insert_val = ''        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        #                           0          1     2        3         4                 5                  6                  7                   8               9        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The race name does not exist!')        else:            if info in accepted_strings:                if info == accepted_strings[0]:                    insert_col = 'race_name'                    insert_val = value                elif info == accepted_strings[1]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_hp'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[2]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_mp'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[3]:                    if can_be_int(value):                        if int(value) > 0:                            insert_col = 'val_ep'                            insert_val = value                        else:                            await ctx.send('The value must be not negative! Please adjust this value!')                            return                    else:                        await ctx.send('The value must be an integer! Please adjust this value!')                        return                elif info == accepted_strings[4]:                    if value.find(',') != -1:                        x = value.split(',')                        if len(x) == 6 and can_list_be_int(x):                            insert_col = 'change_stat_list'                            insert_val = value                        elif len(x) != 6:                            await ctx.send(f'THe list is to small! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        elif not can_list_be_int(x):                            await ctx.send(f'The value does not contain integers! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                        else:                            await ctx.send(f'There is an unknown error with this list! The current list is {result[4]}! Please manipulate these values and paste in this format!')                            return                    else:                        await ctx.send(                            f'The value is in an incorrect form! The current list is {result[4]}! Please manipulate these values and paste in this format!')                        return                elif info == accepted_strings[5]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[5]                        x += f',{value}'                        insert_col = 'condtion_immune'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[6]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[5]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        insert_col = 'condtion_immune'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[7]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[6]                        x += f',{value}'                        insert_col = 'condtition_strength'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[8]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[6]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        insert_col = 'condtition_strength'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[9]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[7]                        x += f',{value}'                        insert_col = 'condition_vulnerable'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[10]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT condition_name, condition_type, condition_turns, condition_damage, condition_effect_roll, condition_gain_loss, condition_effect_stat, cause_lose_turn, condition_desc FROM effectcond WHERE guild_id = {ctx.guild.id} AND condition_name = {value}')                    res = cursor.fetchone()                    if res is not None:                        x = result[7]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        insert_col = 'condition_vulnerable'                        insert_val = x                    else:                        await ctx.send('This condition does not exist!')                        return                elif info == accepted_strings[11]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {name}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        x += f',{value}'                        insert_col = 'ability_list'                        insert_val = x                    else:                        await ctx.send('This ability does not exist!')                        return                elif info == accepted_strings[12]:                    db = sqlite3.connect('main.sqlite')                    cursor = db.cursor()                    cursor.execute(                        f'SELECT ability_name, ability_type, buff_range, buff_condition, ability_desc FROM abilities WHERE guild_id = {ctx.guild.id} AND ability_name = {name}')                    res = cursor.fetchone()                    if res is not None:                        x = result[8]                        x = x.replace(value, '')                        x = x.replace(',,', ',')                        x = x.rstrip(',')                        insert_col = 'ability_list'                        insert_val = x                    else:                        await ctx.send('This ability does not exist!')                        return                elif info == accepted_strings[13]:                    insert_col = 'race_description'                    insert_val = value                else:                    await ctx.send(f'''The value entered does not match the one of the acceptable values!                    ```update_race [name] [info] [value]                    where name is the name of the race                    where info is the info you want to change                        The acceptable values are                            name to change the name of the race                            set_hp to set the hp value of the race                            set_mp to set the mp value of the race                            set_ep to set the ep value of the race                            change_stat_list to change the list of what is added or removed from a stat                            add_immunity to add a condition the race is immune to                            remove_immunity to remove a condition the race is immune to                            add_resistance to add a condition the race is resistant to                            remove_resistance to remove a condition the race is resistant to                            add_vulnerability to add a condition the race is vulnerable to                            remove_vulnerability to remove a condition the race is vulnerable to                            add_ability to add an ability the race has                            remove_ability to remove an ability the race has                            desc to change the race description                    where the value is the value of the info you want to change```''')                    return                db = sqlite3.connect('main.sqlite')                cursor = db.cursor()                sql = (f'UPDATE races SET {insert_col} = ? WHERE guild_id = ? AND race_name = ?')                val = (insert_val, ctx.guild.id, name)                cursor.execute(sql, val)                db.commit()                cursor.close()                db.close()            else:                await ctx.send(f'''The value entered does not match the one of the acceptable values!                ```update_race [name] [info] [value]                where name is the name of the race                where info is the info you want to change                    The acceptable values are                        name to change the name of the race                        set_hp to set the hp value of the race                        set_mp to set the mp value of the race                        set_ep to set the ep value of the race                        change_stat_list to change the list of what is added or removed from a stat                        add_immunity to add a condition the race is immune to                        remove_immunity to remove a condition the race is immune to                        add_resistance to add a condition the race is resistant to                        remove_resistance to remove a condition the race is resistant to                        add_vulnerability to add a condition the race is vulnerable to                        remove_vulnerability to remove a condition the race is vulnerable to                        add_ability to add an ability the race has                        remove_ability to remove an ability the race has                        desc to change the race description                where the value is the value of the info you want to change```''')                return    @update_race.error    async def update_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```update_race [name] [info] [value]            where name is the name of the race            where info is the info you want to change                The acceptable values are                    name to change the name of the race                    set_hp to set the hp value of the race                    set_mp to set the mp value of the race                    set_ep to set the ep value of the race                    change_stat_list to change the list of what is added or removed from a stat                    add_immunity to add a condition the race is immune to                    remove_immunity to remove a condition the race is immune to                    add_resistance to add a condition the race is resistant to                    remove_resistance to remove a condition the race is resistant to                    add_vulnerability to add a condition the race is vulnerable to                    remove_vulnerability to remove a condition the race is vulnerable to                    add_ability to add an ability the race has                    remove_ability to remove an ability the race has                    desc to change the race description                where the value is the value of the info you want to change```''')    @commands.command()    @commands.has_guild_permissions(administrator=True)    async def delete_race(self, ctx, name):        db = sqlite3.connect('main.sqlite')        cursor = db.cursor()        cursor.execute(f'SELECT race_name, val_hp, val_mp, val_ep, stats_plus_min, condtion_immune, condtition_strength, condition_vulnerable, ability_list, race_description FROM races WHERE guild_id = {ctx.guild.id} AND race_name = {name}')        result = cursor.fetchone()        if result is None:            await ctx.send(f'The race {name} is not a current race!')        else:            db = sqlite3.connect('main.sqlite')            cursor = db.cursor()            sql = ('DELETE FROM races WHERE guild_id = ? AND race_name = ?')            val = (ctx.guild.id, name)            db.commit()            cursor.close()            db.close()    @delete_race.error    async def delete_race_error(self, ctx, error):        if isinstance(error, commands.MissingRequiredArgument):            await ctx.send(f'''You are missing an argument!            ```delete_race [name]            where name is the race name```''')    ####################################################################################################################    #   Classes                                                                                                        #    ####################################################################################################################def setup(client):    client.add_cog(Characters(client))